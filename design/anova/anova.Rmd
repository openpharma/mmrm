---
title: "Hypothese Testing (Three types of ANOVA) for MMRM"
output: html_document
editor_options:
  chunk_output_type: console
  markdown:
    wrap: 72
---


# Backgroun

This [blog](https://www.r-bloggers.com/2011/03/anova-%E2%80%93-type-iiiiii-ss-explained/) has a nice summary of it.
The original [post](http://goanna.cs.rmit.edu.au/fscholer/anova.php) is not accessible now.

And we can also refer to this [page](https://agstats.io/tutorials/sas-proc-mixed)

Some available code from [glmmTMB](https://github.com/glmmTMB/glmmTMB/blob/master/glmmTMB/R/Anova.R)

SAS also has some paper on this topic, but from a different angle.
It uses estimable functions to construct the three types of hypothesis.

See paper https://doi.org/10.1080/03610928008827869 and https://support.sas.com/documentation/onlinedoc/stat/131/introglmest.pdf.

## SAS results

Using `anova.sas` we have the following results.
Please note that type 1 result is dependent on the order of testing so it is not included here for simplicity.
Type 2 and 3 tests are independent of the order of model parameter provided to the procedure.


| type 2       | df|        ddf       |      F value      |        Pr > F        |
|--------------|---|------------------|-------------------|----------------------|
| ARMCD        | 1 | 177.578206251403 | 33.1870413448661  | 3.62415957242791e-08 |
| AVISIT       | 3 | 336.480231426766 | 116.732733882531  | 7.97333625254255e-52 |
| AVISIT*ARMCD | 3 | 335.929182055453 | 0.345902681482862 | 0.792143200158668    |


| type 3       | df|        ddf       |      F value      |        Pr > F        |
|--------------|---|------------------|-------------------|----------------------|
| ARMCD        | 1 | 177.848284237308 | 33.0036689632883  | 3.91621392761811e-08 |
| AVISIT       | 3 | 335.929182055453 | 116.539400933677  | 9.71251157971289e-52 |
| AVISIT*ARMCD | 3 | 335.368828514443 | 0.345902681482865 | 0.792143224823356    |


## emmeans joint_tests

```{r}
library(mmrm)
fit <- mmrm(FEV1 ~ ARMCD + AVISIT + ARMCD * AVISIT + ar1(AVISIT | USUBJID), data = fev_data)
emmeans::joint_tests(fit)
```


however, the result do not agree well between SAS and R.

Using "satterthwaite df" the F statistic is close, but the d.f. is not.

```
 model term   df1    df2 F.ratio p.value
 ARMCD          1 177.85  33.004  <.0001
 AVISIT         3 309.60 116.540  <.0001
 ARMCD:AVISIT   3 309.60   0.346  0.7921
```

## Finding suitable contrasts

similar to emmeans::joint_tests() obtain a contrasts. In `emmeans` the contrasts can be obtained for Type 3, and
use these contrasts to send to `df_md` we get exactly the same results with SAS.

```{r}
args <- emmeans:::.zap.args(object = fit, cov.reduce = emmeans:::meanint, omit = "submodel")
object <- do.call(emmeans:::ref_grid, args)
by <- NULL
facs <- setdiff(names(object@levels), c(by, "1"))
emm <- emmeans::emmeans(fit, facs[2], by = by)
emmgrid <- emmeans::contrast(emm, interaction = "consec", by = union(by, NULL))
tst <- emmeans::test(emmgrid, by = by, joint = TRUE, status = TRUE)
ef <- attr(tst, "est.fcns")
```

```
$ARMCD
     [,1]       [,2] [,3] [,4] [,5]       [,6]       [,7]       [,8]
[1,]    0 -0.9176629    0    0    0 -0.2294157 -0.2294157 -0.2294157

$`ARMCD:AVISIT`
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
[1,]    0    0    0    0    0   -1    0    0
[2,]    0    0    0    0    0    0   -1    0
[3,]    0    0    0    0    0    0    0   -1

$AVISIT
     [,1] [,2]       [,3]       [,4]       [,5]       [,6]       [,7]
[1,]    0    0 -0.8944272  0.0000000  0.0000000 -0.4472136  0.0000000
[2,]    0    0  0.0000000 -0.8944272  0.0000000  0.0000000 -0.4472136
[3,]    0    0  0.0000000  0.0000000 -0.8944272  0.0000000  0.0000000
  [,8]
[1,]  0.0000000
[2,]  0.0000000
[3,] -0.4472136
```

### Obtain the contrasts

```
df_md(fit, contrasts)
```

### Initial thoughts

Using doolittle method to obtain the contrasts seems plausible? but this is initial.

```{r}
doolittle <- function(m) {
  assert_matrix(m)
  for (i in seq_len(nrow(m))) {
    for (j in seq_len(i - 1)) {
      m[i, ] <- m[i, ] - m[i, j] * m[j, ]
    }
    if (m[i, i] == 0) {
      m[i, ] <- 0
    } else {
      m[i, ] <- m[i, ] / m[i, i]
    }
  }
  return(m)
}

normalize_mat <- function(m) {
  m / rowSums(m^2)
}

mx <- model.matrix(fit)
dl <- doolittle(t(mx) %*% mx)
df_md(fit, dl[6:8, ])
df_md(fit, normalize_mat(dl[6:8, ]))
df_md(fit, dl[2, ]) # d.f. do not match, stat matches a lot ()
```


# Type II Estimable Functions

According to the SAS/STAT® 13.1 User’s Guide, type II estimable can be achieved through

For fixed effect F1:

1. All columns of L associated with effects not containing F1 (except F1) are zero.
2. The submatrix of L associated with effect F1 is $(X_1^\top M X_1)^{-}X_1^\top M X_1$
3. Each of the remaining submatrices of L associated with an effect F2 that contains F1 is $(X_1^\top M X_1)^{-}X_1^\top M X_2$

Note: $X^{-}$ is the generalized g2-inverse of $X$ if $X$ is a square matrix. And $(X^\top X)^{-}X^\top X$ is used
in `PROC GLM` to represent `L` symbolically.
And
$X_0$ : columns of $X$ whose associated effects do not contain F1
$X_1$ : columns of $X$ associated with F1
$X_2$ : columns of $X$ associated with F2 that contains F1
$M = I - X_0(X_0^\top X_0)^{-}X_0^\top$.

for the following mmrm model
```{r}
fit <- mmrm(FEV1 ~ ARMCD + AVISIT + ARMCD * AVISIT + ar1(AVISIT | USUBJID), data = fev_data)
```

the design matrix is

```
mx <- model.matrix(fit)
```

and the effect is

| effect |  column in design matrix |
|--------|--------------------------|
|  mu    |        1                 |
| ARMCD  |        2                 |
| AVISIT |        3,4,5             |
| ARMCD * AVISIT  |    6,7,8        |

the effect `ARMCD * AVISIT` contains `ARMCD` and `AVISIT`.

Let's calculate the `L` for `ARMCD` and `AVISIT`

### ARMCD part
```{r}
x0 <- mx[, c(1, 3, 4, 5)]
x1 <- mx[, c(2), drop = FALSE]
x2 <- mx[, c(6, 7, 8)]

l <- rep(0, 8) # initial values
m <- diag(rep(1, nrow(x0))) - x0 %*% MASS::ginv(t(x0) %*% x0) %*% t(x0)
l1_coef <- MASS::ginv(t(x1) %*% m  %*% x1) %*% t(x1) %*% m %*% x1
l[c(2)] <- l1_coef

l2_coef <- MASS::ginv(t(x1) %*% m  %*% x1) %*% t(x1) %*% m %*% x2
l[c(6, 7, 8)] <- l2_coef

df_md(fit, l) # very close !
```

### AVISIT part

```{r}
x0 <- mx[, c(1, 2)]
x1 <- mx[, c(3, 4, 5), drop = FALSE]
x2 <- mx[, c(6, 7, 8)]

l <- matrix(0, nrow = 3, ncol = 8) # initial values
m <-  diag(rep(1, nrow(x0))) - x0 %*% MASS::ginv(t(x0) %*% x0) %*% t(x0)
l1_coef <- MASS::ginv(t(x1) %*% m  %*% x1) %*% t(x1) %*% m %*% x1
l[, c(3, 4, 5)] <- l1_coef

l2_coef <- MASS::ginv(t(x1) %*% m  %*% x1) %*% t(x1) %*% m %*% x2
l[, c(6, 7, 8)] <- l2_coef

df_md(fit, l) # also close
```

### ARMCD * AVISIT

```{r}
x0 <- mx[, c(1, 2, 3, 4, 5)]
x1 <- mx[, c(6, 7, 8), drop = FALSE]

l <- matrix(0, nrow = 3, ncol = 8) # initial values
m <- x0 %*% MASS::ginv(t(x0) %*% x0) %*% t(x0)
l1_coef <- MASS::ginv(t(x1) %*% m  %*% x1) %*% t(x1) %*% m %*% x1
l[, c(6, 7, 8)] <- l1_coef

df_md(fit, l) # close to type 3?
```

Note: according to SAS guide, is a effect is not contained in any other effect, type 2,3 and 4 are equivalent.

## Basic summary

With the proposed method, we have very close result to what SAS have.
And given that we do not allow singularity in fitting (those aliased cols are removed from model fitting),
the process can be further simplified to use identity matrix for the f1 cols.

Note: Zapping might be needed to remove very small numbers.

# Type III Estimable Functions

Type III is constructed assuming that we have a balanced design.

According to the SAS/STAT® 13.1 User’s Guide, type II estimable can be achieved through

For fixed effect F1:

1. For effect in the model (except F1) that contains F1, equate the coefficients in the general form of estimable function to zero
2. If necessary, equate new symbols to compound expressions in the F1 block
3. Equate all symbolic coefficients outside F1 block to a linear function of the symbols in the F1 block.

In practice, if a effect is not contained in any other tests, use its orthogonal form (identity matrix) in the corresponding submatrix, e.g. for `AVISIT * PARMAMCD`
If a effect is contained in other effects, for that part we try to equate the values.

In our case of design matrix, testing `ARMCD`, there are 4 levels in total for `AVISIT * ARMCD`.
The coefficients for the effect `ARMCD` is 1, so each value for the `AVISIT * ARMCD` is 1/4.

For each level of `AVISIT`, there are 2 levels for `AVISIT * ARMCD`.
So the coefficients for `AVISIT * ARMCD` is 1/2.

However, this only works for the simplest case that there is no restriction on the design matrix.
In general, we will not have such cases so it is fine.

Note: using Type II on perfectly balanced data, the result should be the same for Type III.

### ARMCD part
```{r}
l <- rep(0, 8) # initial values
l[2] <- 1
l[6:8] <- 1 / 4

df_md(fit, l) # very close !
```

### AVISIT part

```{r}
l <- matrix(0, nrow = 3, ncol = 8) # initial values
l[, c(3, 4, 5)] <- diag(rep(1, 3))
l[, c(6, 7, 8)] <- diag(rep(1, 3)) / 2

df_md(fit, l) # also close
```


# Prototypes

```{r}
get_l_matrix_type2 <- function(fit, var) {
  mx <- component(fit, "x_matrix")
  asg <- attr(mx, "assign")
  formula <- fit$formula_parts$model_formula
  tms <- terms(formula)
  fcts <- attr(tms, "factors")[-1, , drop = FALSE] # discard the response
  ods <- attr(tms, "order")
  idx <- which(var == colnames(fcts))
  cols <- which(asg == idx)
  all_vars <- row.names(fcts)[which(fcts[, idx] == 1)]
  all_levels <- vapply(all_vars, function(x) {length(attr(fit$tmb_data$data[[x]], "levels"))}, FUN.VALUE = 1)
  total_levels <- prod(all_levels)
  lvls <- prod(all_levels - 1)
  l_mx <- matrix(0, nrow = lvls, ncol = ncol(mx))
  l_mx[, cols] <- diag(rep(1, length(cols)))
  for (i in seq_len(ncol(fcts))) {
    x1 <- mx[, cols, drop = FALSE]
    if (ods[i] >= ods[idx] && all(fcts[, i] >= fcts[, idx])) {
      x0 <- mx[, which(!asg %in% c(i, idx)), drop = FALSE]
      x2 <- mx[, which(asg == i), drop = FALSE]
      m <- diag(rep(1, nrow(x0))) - x0 %*% solve(t(x0) %*% x0) %*% t(x0)
      l_coefs <- solve(t(x1) %*% m %*% x1) %*% t(x1) %*% m %*% x2
      l_mx[, which(asg == i)] <- l_coefs
    }
  }
  l_mx
}

get_l_matrix_type3 <- function(fit, var) {
  mx <- component(fit, "x_matrix")
  asg <- attr(mx, "assign")
  formula <- fit$formula_parts$model_formula
  tms <- terms(formula)
  fcts <- attr(tms, "factors")[-1, , drop = FALSE] # discard the response
  ods <- attr(tms, "order")
  idx <- which(var == colnames(fcts))
  cols <- which(asg == idx)
  all_vars <- row.names(fcts)[which(fcts[, idx] == 1)]
  all_levels <- vapply(all_vars, function(x) {length(attr(fit$tmb_data$data[[x]], "levels"))}, FUN.VALUE = 1)
  total_levels <- prod(all_levels)
  lvls <- prod(all_levels - 1)
  l_mx <- matrix(0, nrow = lvls, ncol = ncol(mx))
  l_mx[, cols] <- diag(rep(1, length(cols)))
  for (i in seq_len(ncol(fcts))) {
    x1 <- mx[, cols, drop = FALSE]
    if (ods[i] > ods[idx] && all(fcts[, i] >= fcts[, idx])) {
      new_cols <- which(asg == i)
      a_vars <- row.names(fcts)[which(fcts[, i] == 1)]
      a_levels <- vapply(a_vars, function(x) {length(attr(fit$tmb_data$data[[x]], "levels"))}, FUN.VALUE = 1)
      t_levels <- prod(a_levels)
      l_mx[, which(asg == i)] <- l_mx[, which(asg == idx)] / t_levels * lvls
    }
  }
  l_mx
}

get_l_matrix_type2(fit, "ARMCD")
get_l_matrix_type3(fit, "ARMCD")

get_l_matrix_type2(fit, "AVISIT")
get_l_matrix_type3(fit, "AVISIT")

get_l_matrix_type2(fit, "ARMCD:AVISIT")
get_l_matrix_type3(fit, "ARMCD:AVISIT")

# call df_md on these l matrix to obtain the results.
```

Note: design matrix involved with numerics are still not implemented yet.

### Additional tries
```{r}

zap_small <- function(x) {
  x[abs(x) < sqrt(.Machine$double.eps)] <- 0
  x
}

fit <- mmrm(FEV1 ~ RACE + AVISIT + RACE * AVISIT + ar1(AVISIT | USUBJID), data = fev_data)

x0 <- mx[, c(1, 4:6)]
x1 <- mx[, 2:3, drop = FALSE]
x2 <- mx[, c(7:12)]

l <- matrix(0, 2, 12) # initial values
m <- diag(rep(1, nrow(x0))) - x0 %*% MASS::ginv(t(x0) %*% x0) %*% t(x0)
l1_coef <- MASS::ginv(t(x1) %*% m  %*% x1) %*% t(x1) %*% m %*% x1
l[, 2:3] <- l1_coef

l2_coef <- MASS::ginv(t(x1) %*% m  %*% x1) %*% t(x1) %*% m %*% x2
l[, 7:12] <- l2_coef

df_md(fit, l) # very close !
```