---
title: "Adding anova() to mmrm"
author: "Nik Krieger"
format: gfm
editor: visual
---

## Setup

```{r setup}
library(mmrm)
```

# Background

A current drawback of `mmrm` is that it does not support `stats::anova()` (i.e., `anova.mmrm()` does not exist). This is discussed here: <https://github.com/openpharma/mmrm/issues/164>

## Key points from the GitHub issue

The title of the issue is centered on incorporating the Likelihood Ratio Test for `mmrm` fits: "\[feature request\] add likelihood ratio test."

There is consensus that this goal of obtaining LRT results would be available via a new `anova()` method for `mmrm` model fits.

### Models should be compared to check if they are nested:

-   Nested sets of covariates. See: <https://github.com/openpharma/mmrm/issues/164#issuecomment-1446364890>
-   "Nested" covariance structures (e.g., unstructured + any structured; AR1 being a special case of Toeplitz). See: <https://github.com/openpharma/mmrm/issues/164#issuecomment-1446627674> and the **Nested covariance structures proofs** appendix below.
-   **Not both** of the above, as this would be too complicated.

### Accommodate comparison of models that used different data sets

It's possible that the larger model was fit with an augmented data set (<https://github.com/openpharma/mmrm/issues/164#issuecomment-1446839199>). In this case, it would be advantageous for the function to refit the model (<https://github.com/openpharma/mmrm/issues/164#issuecomment-1447419569>).

## Additional considerations

### Providing only one fit to `anova.mmrm()`

`?stats::anova` declares that if only one model fit is provided, the function will calculate the significance of model terms. The `anova.mmrm()` should honor this.

### Following the lead of `anova()` methods in `nlme` and `lme4`

In order that `anova.mmrm()` may be comparable to `anova()` methods in the `nlme` and `lme4` packages, it shall contain the following arguments:

-   `test` argument to opt in/out of obtaining LRT results (see `?nlme::anova.lme`). The function will return degrees of freedom, AIC, BIC, and log-likelihood regardless.
-   `refit` arguments to allow for refitting the models (see `?lme4::anova.merMod`).

# Prerequisite: augment `logLik.mmrm_tmb()`

This function needs to return more data in the `attributes()` of the returned value:

-   `nall`, `nobs`, and `df`
-   Add `"logLik"` to the `class()` of the returned value

Prototype:

```{r}
#' @describeIn mmrm_tmb_methods obtains the attained log likelihood value.
#' @param complete (`logical`)\cr Indicates whether or not to include aliased
#'  coefficients set to `NA`.
#' @importFrom stats logLik
#' @exportS3Method
#' @examples
#' # Log likelihood given the estimated parameters:
#' logLik(object)
logLik.mmrm_tmb <- function(object, complete = TRUE, ...) {
  out <- -component(object, "neg_log_lik")

  # Number of parameters
  n_params <- component(object, "n_theta")

  # Number of estimated coefficients
  n_fixed_effects <- 
    length(
      component(
        object, 
        if (complete) "beta_est_complete" else "beta_est"
      )
    )

  structure(out, df = n_params + n_fixed_effects, class = "logLik")
}
```

# Designing `anova.mmrm()`

## Function specification

### Usage

```{r eval=FALSE}
## S3 method for class 'mmrm'
anova(object, ..., test = TRUE, refit = FALSE)
```

### Arguments

|  |  |
|----|----|
| `object` | An object inheriting from class `mmrm`: a fitted mixed model with repeated measures. |
| `...` | Other optional fitted model objects inheriting from class `mmrm`. |
| `test` | Logical indicating whether the output should include likelihood ratio test results comparing the model fits to one another. Defaults to `TRUE`. |
| `refit` | Logical indicating whether the models should be refitted with the least common data set before calculating results. This is ignored if the models all have the same underlying data set. If `refit = FALSE` and the models have different underlying data sets, an error will be thrown. Defaults to `FALSE`. |

## Function outline

### Plain language

#### Special case: supplying only one model fit

If the user provides only one model fit to `anova.mmrm()`, the function will calculate and return the significance of the model terms in a data frame.

#### Comparing multiple model fits

If the user provides more than one model fit, a data frame is produced with a row for each model, and the columns will contain identifying information as well as standard diagnostics (e.g., AIC; log likelihood).

If the user supplied `test = TRUE`, the model fits are subject to further tests to ensure they are nestable. If the data sets for the fits are not the same and the user supplied `refit = TRUE`, the smallest common data set is determined using `Reduce(f = merge)`, and all models are refitted using this data set. The pairs of models then undergo likelihood ratio testing, and the results are augmented into the data frame of results.

### Prototype code

#### `anova.mmrm()`

```{r }
anova.mmrm <- function (object, ..., test = TRUE, refit = FALSE) {
  
  checkmate::assert_class(object, "mmrm")
  
  fits <- list(object, ...)
  # If there are objects supplied to "..."
  if (length(fits) > 1L) {
    
    # Ensure all objects in ... are mmrm fits
    lapply(fits[-1L], checkmate::assert_class, classes = "mmrm", .var.name = "...")
    
    # If the data are not all the same and refit = TRUE, refit all with the 
    # smallest common data set
    if (refit && !h_check_same_data(fits)) {
      fits <- lapply(fits, h_refit_mmrm, data = h_fits_common_data(fits))
    }
    
    # vector of log likelihood results for the fits
    LL_vec <- lapply(fits, logLik.mmrm_tmb)
    
    # Calculate the standard diagnostics.
    out <-
      data.frame(
        Model = seq_along(fits),
        df = vapply(LL_vec, attr, FUN.VALUE = numeric(1L), "df"), 
        AIC = vapply(fits, AIC, numeric(1)),
        BIC = vapply(fits, BIC, numeric(1)),
        logLik = as.numeric(LL_vec)
      )

    # If the user has requested the likelihood ratio test...
    if (test) {
      # First iterate through and check the models to make sure their covariates
      # and covariance structures are nested
      for (i in seq_along(fits)[-1L]) {
        h_assert_nested_models(fits[[i - 1L]], fits[[i]])
      }
      
      # If we didn't refit, throw errors if not all data are the same
      if (!refit && !h_check_same_data(fits)) {
        stop(
          "Likelihood ratio testing requires all fits to use the same data.",
          " Not all fits have the same data and refit = FALSE.",
          " Consider setting test = FALSE or refit = TRUE.",
          call. = FALSE
        )
      }
        
      # Label for the pair being compared (e.g., "3 vs 4")
      out$test <- c(NA, paste(out$Model[-length(fits)], "vs", out$Model[-1L]))
      
      # Calculate the log of likelihood ratios between the pairs using
      # base::diff()
      out$log_likelihood_ratio <- c(NA, diff(out$logLik))
      
      # Calculate the p-value using the log likelihood ratios and differences in
      # df
      out$p_value <-
        pchisq(
          2 * abs(out$log_likelihood_ratio),
          df = abs(diff(out$df)), 
          lower.tail = FALSE
        )
    }
    
    out$call <- vapply(lapply(fits, component, "call"), deparse1, character(1L))
    
  } else { 
    out <- h_anova_single_mmrm_model(object)
  }
  
  out
}
```

#### Supporting functions:

```{r}
h_check_same_data <- function(fits) {
  # Grab the data frames behind the model fits into a separate list.
  dfs <- lapply(fits, h_get_minimal_fit_data)
  
  for (i in seq_along(fits)[-1L]) {
    
    # First check the number of rows.
    if (nrow(dfs[[i - 1L]]) != nrow(dfs[[i]])) {
      return(FALSE)
    }
    
    # Ensure previous df's columns is a subset of the current df's columns
    cols_prev <- colnames(dfs[[i - 1L]])
    cols_current <- colnames(dfs[[i]])
    if (anyNA(match(cols_prev, cols_current))) {
      return(FALSE)
    }
    
    # If we're on the first iteration, sort the first data frame.
    if (i == 2L) dfs[[1L]] <- h_df_sort_all(dfs[[1L]])
    
    # Pull prev df's columns to the front of current df. Then sort.
    dfs[[i]] <- h_df_sort_all(dfs[[i]][union(cols_prev, cols_current)])
    
    # Ensure the common columns are the same
    if (!identical(dfs[[i - 1L]], dfs[[i]][cols_prev])) {
      return(FALSE)
    }
  }
  
  TRUE
}


# Iteratively merge the data sets underlying the fits to get the common rows
h_fits_common_data <- function(fits) {
  dfs <- lapply(fits, h_get_minimal_fit_data)
  out <- Reduce(merge, dfs)
  out
}




# Refit a single mmrm model with a data set.
h_refit_mmrm <- function(fit, data) {
  
  # Grab the model call
  expr <- component(fit, "call")
  
  # Grab the environment of the model's formula
  env <- environment(fit[["formula_parts"]][["full_formula"]])
  
  # Generate a name guaranteed not to be in env nor its enclosing frames
  data_name <- h_generate_new_name("data", env)
  
  # Create a child environment whose parent is the model's environment
  env <- new.env(parent = env)
  
  # bind the new data to the new name in the new, child environment
  env[[data_name]] <- data
  
  # Force the data argument of the model call to be the new name
  expr[["data"]] <- as.name(data_name)
  
  # Evaluate the updated model call in the appropriate environment
  fit <- eval(expr, env)
  
  fit
}



# Generates a name that is guaranteed not to be found in env nor its enclosing
# frames
h_generate_new_name <- function(x, env) {
  # first, force x to be a syntactically valid name(s)
  x <- make.names(x, unique = TRUE)
  
  # As long as we keep finding an object in env (or its enclosing frames) whose
  # name is the same as the last element of x...
  while (exists(x[length(x)], envir = env, inherits = TRUE)) {
    # ...copy the first element of x and append it to the end. Run
    # make.names(unique = TRUE) again in the hopes that the resulting last
    # element will not be found on the search path next time
    x <- make.names(x[c(seq_along(x), 1L)], unique = TRUE)
  }
  # If we've gotten here, the last element of doesn't exist in env or its
  # enclosing frames
  x[length(x)]
}




# Compares two models to see if they are properly nested.
# Errors out if they don't have the same visit, subject, and grouping vars
# Errors out if the first model's covariates isn't a subset of the second
# Errors out if the models have incompatible covariance structures
# Warns if the models have the same covariates and covariance structure
h_assert_nested_models <- function(model_basic, model_augmented) {
  model_basic <- model_basic[["formula_parts"]]
  model_augmented <- model_augmented[["formula_parts"]]

  if (!identical(model_basic[["visit_var"]], model_augmented[["visit_var"]])) {
    stop("Models must all have the same visit variable.", call. = FALSE)
  }

  if (!identical(model_basic[["subject_var"]], model_augmented[["subject_var"]])) {
    stop("All models must have the same subject variable.", call. = FALSE)
  }

  if (!identical(model_basic[["group_var"]], model_augmented[["group_var"]])) {
    stop("All models must have the same grouping variable.", call. = FALSE)
  }

  covar_nesting <- h_check_covar_nesting(model_basic, model_augmented)
  cov_struct_nesting <- h_check_cov_struct_nesting(model_basic, model_augmented)
  
  if (covar_nesting == "identical" && cov_struct_nesting == "identical") {
    warning("Two models in the sequence have identical covariates and ",
            "covariance structures.", call. = FALSE)
  }
  
  NULL
}




# Checks the covariates of two models to see if they are nested (or identical).
# The first model's covariates must be a subset of the second model's covariates
h_check_covar_nesting <- function(model_basic, model_augmented) {
  basic_covars <- attr(terms(model_basic[["model_formula"]]), "term.labels")
  aug_covars <- attr(terms(model_augmented[["model_formula"]]), "term.labels")

  if (anyNA(match(basic_covars, aug_covars))) {
    stop("Each model's covariates must be a subset of the next model's ",
         "covariates.", call. = FALSE)
  }

  if (anyNA(match(aug_covars, basic_covars))) {
    "nested"
  } else {
    "identical"
  }
}


# Checks the covariance structures of two models to see if they are nested (or
# identical). This is a check against a mathematically determined hierarchy.
h_check_cov_struct_nesting <- function(model_basic, model_augmented) {
  basic_cov_struct <- model_basic[["cov_type"]]
  aug_cov_struct <- model_augmented[["cov_type"]]
  
  # Hierarchy, specifying the "parent" covariance structures of each available 
  # type in mmrm
  cov_struct_nesting <-
    list(
      ad = c("adh", "us"),
      adh = "us",
      ar1 = c("ad", "adh", "ar1h", "toep", "toeph", "us"),
      ar1h = c("adh", "toeph", "us"),
      cs = c("csh", "toep", "toeph", "us"),
      csh = c("toeph", "us"),
      toep = c("toeph", "us"),
      toeph = "us",
      us = character(0L),
      sp_exp = character(0L)
    )
  
  if (identical(basic_cov_struct, aug_cov_struct)) {
    "identical"
  } else if (any(cov_struct_nesting[[aug_cov_struct]] == basic_cov_struct)) {
    "nested"
  } else {
    stop(
      "The covariance structure of each model must be identical to or a ",
      "special case of the preceding model's covariance structure.",
      call. = FALSE
    )
  }
}


# Returns a character vector of the names of the columns actually used in a fit
h_get_minimal_fit_data <- function(fit) {
  predictors <- 
    unique(
      unlist(
        fit[["formula_parts"]][
          c("visit_var", "subject_var", "group_var", "model_var")
        ],
        use.names = FALSE
      )
    )
  terms_attr <- attributes(terms(fit))
  response <- as.character(terms_attr$variables[[terms_attr$response + 1]])
  fit[["data"]][c(response, predictors)]
}


# Sorts a data frame by its columns in the order they appear
h_df_sort_all <- function(df) {
  df[do.call(order, unname(df)), ]
}



h_anova_single_mmrm_model <- function(object) {
  # attributes of terms.object for the model formula without the cov struct
  terms_attr <- attributes(terms(object$formula_parts$model_formula))
  
  # Get a character vector of the terms.
  # Prepend with "(Intercept)" if an intercept is present
  terms <- c(if (terms_attr$intercept) "(Intercept)", terms_attr$term.labels)
  
  # Vector identifying each coefficient's corresponding term
  assign_vec <- attr(component(object, "x_matrix"), "assign")
  
  # Create an identity matrix with a row/col for each coefficient
  identity_mtx <- diag(length(assign_vec))
  
  # Split the rows of identity_mtx according to assign_vec, creating a list of
  # contrast matrices: one for each term in the model.
  contrasts <-
    split.data.frame(identity_mtx, factor(assign_vec, labels = terms))
  
  # Get df_md() results for each contrast matrix. Result is a list of lists
  df_md_results <- lapply(contrasts, df_md, object = object)
  
  # Turn results into a data frame. The row.names identify the terms.
  out <- do.call(rbind, lapply(df_md_results, as.data.frame))
  
  out
}
```

# Examples

## Setup

Using `mmrm::fev_data`, here is a model fit, a reduced version, and a "full" version, which has a more specialized covariance structure.

```{r}
fit <- 
  mmrm(
    FEV1 ~ FEV1_BL + SEX*RACE + ARMCD + toep(AVISIT | USUBJID),
    data = fev_data
  )

fit_reduced <- 
  mmrm(
    FEV1 ~ FEV1_BL + SEX + RACE + ARMCD + us(AVISIT | USUBJID),
    data = fev_data
  )

fit_full <-
  mmrm(
    FEV1 ~ FEV1_BL + SEX*RACE + ARMCD + ar1(AVISIT | USUBJID),
    data = fev_data
  )
```

## Single model

First, run `anova()` on just one model fit:

```{r}
anova(fit)
```

We get the significance of each term in the model.

## Multiple models

Now, use multiple models. Note that the likelihood ratio test is included by default.

```{r}
anova(fit_reduced, fit, fit_full)
```

## Nesting checks

Note that models can only increase in terms from left to right. The following will not work because `fit_full` has more terms than `fit_reduced`.

```{r error=TRUE}
anova(fit_full, fit_reduced)
```

Furthermore, the specificity of covariance structures can only increase from left to right. Therefore, even though `fit` and `fit_full` have the same terms, the following will not work because the covariance structure of `fit_full`, `ar1`, is a special case of the covariance structure of `fit`, `toep`:

```{r error=TRUE}
anova(fit_full, fit)
```

## Data sameness checks

### Setup

First, let's create a model fit that's based on more data:

```{r}
fev_more_data <-
  rbind(
    fev_data,
    transform(
      fev_data[1:200, ],
      FEV1 = FEV1 + rnorm(200, sd = sd(FEV1) / 10),
      FEV1_BL = FEV1_BL + rnorm(200, sd = sd(FEV1_BL) / 10)
    )
  )
fev_more_data$USUBJID <-
  factor(rep(1:250, each = 4), labels = paste0("PT", 1:250))

fit_more_data <-
  mmrm(
    FEV1 ~ FEV1_BL + SEX*RACE + ARMCD + toep(AVISIT | USUBJID),
    data = fev_more_data
  )
```

### Different data, `refit = FALSE`

We cannot simply slot in the new `fit_more_data` because it has a different underlying data set:

```{r error=TRUE}
anova(fit_reduced, fit_more_data, fit_full)
```

### Different data, `refit = TRUE`

Setting `refit = TRUE` makes it work:

```{r}
anova(fit_reduced, fit_more_data, fit_full, refit = TRUE)
```

## Bypassing `LRT`

Note that we also have the option to forego the likelihood ratio testing if we want the other results and do not want to refit:

```{r}
anova(fit_reduced, fit, fit_full, test = FALSE)
```

# Appendix: nested covariance structures

For all covariance structures described below, let $i$ and $j$ be the indices of the time points of a model. Therefore, $i$ and $j$ can each take a value in the sequence $\{1, 2, ...\}$, and the $i,j$ element of the covariance matrix is the variance between the $i$th observation and the $j$th observation.

## Unstructured covariance

Tautologically, all covariance structures are special cases of an unstructured covariance, and a model with a covariance structure can be considered "nested" within an model without a covariance structure, assuming that the covariates are also nested.

## Homogeneous and heterogeneous

All homogeneous covariance structures are special cases of their heterogeneous counterparts. Let $\sigma_i = \sigma$ and $\sigma_j = \sigma$

Therefore:

### `ad` is nested within `adh`:

$$
\sigma_{i}\sigma_{j}\prod_{k=i}^{j-1}\rho_{k} = \sigma\cdot\sigma\prod_{k=i}^{j-1}\rho_{k} = \sigma^{2}\prod_{k=i}^{j-1}\rho_{k}
$$

### `ar1` is nested within `ar1h`

$$
\sigma_{i}\sigma_{j}\rho^{\left \vert {i-j} \right \vert} = \sigma\cdot\sigma\rho^{\left \vert {i-j} \right \vert} = \sigma^{2}\rho^{\left \vert {i-j} \right \vert}
$$

### `cs` is nested within `csh`

$$
\sigma_{i}\sigma_{j}\left[ \rho I(i \neq j)+I(i=j) \right] = \sigma\cdot\sigma\left[ \rho I(i \neq j)+I(i=j) \right] = \sigma^{2}\left[ \rho I(i \neq j)+I(i=j) \right]
$$

### `toep` is nested within `toeph`

$$
\sigma_{i}\sigma_{j}\rho_{\left \vert {i-j} \right \vert} = \sigma\cdot\sigma\rho_{\left \vert {i-j} \right \vert} = \sigma^2\rho_{\left \vert {i-j} \right \vert}
$$

## Other hierarchies

We will now restrict the correlations in one covariance structure to produce another covariance structure in this set, demonstrating that they are nested. We will only do this for the homogeneous structures, since the heterogeneous ones plainly follow the same pattern.

### `ar1` is nested within `ad`

Let $\rho_k$ = $\rho$

Therefore:

$$
\sigma^2\prod_{k=i}^{j-1}\rho_{k} = \sigma^2\prod_{k=i}^{j-1}\rho = \sigma^2\rho^{\vert (j-1)-i+1\vert} = \sigma^2\rho^{\vert j-i\vert} = \sigma^2\rho^{\vert i-j\vert} 
$$

### `ar1` is nested within `toep`

Let $\rho$ be a value not necessarily in the sequence $\{\rho_0, \rho_1, \rho_2, ...\}$

Let $\rho_k = \rho^k$

Therefore:

$$
\sigma^2\rho_{\left \vert {i-j} \right \vert} = \sigma^{2}\rho^{\left \vert {i-j} \right \vert}
$$

### `cs` is nested within `toep`

Let $\rho$ be a value not necessarily in the sequence $\{\rho_0, \rho_1, \rho_2, ...\}$

Let $\rho_0 = 1$

Let $\rho_k=\rho$ $\forall$ $k \in \{1, 2, ...\}$

Observe that:

$$
ab = a(b\cdot I(true) + b\cdot I(false))
$$

Observe also that when $i \neq j$, $\left \vert i - j \right \vert \in \{1, 2, ...\}$, and when $i=j$, $\left \vert i - j \right \vert = 0$.

Therefore:

$$
\sigma^2\rho_{\left \vert {i-j} \right \vert} = \sigma^2\left[\rho_{\left \vert {i-j} \right \vert} I(i \neq j) + \rho_{\left \vert {i-j} \right \vert} I(i=j) \right] 
\\= \sigma^2\left[\rho I(i \neq j) + \rho_0 I(i=j) \right] 
\\= \sigma^2\left[\rho I(i \neq j) + 1 \cdot I(i=j) \right] 
\\= \sigma^{2}\left[ \rho I(i \neq j)+I(i=j) \right]
$$

## Resulting `list` object describing the covariance structure nesting hierarchy

```{r}
list(
  ad = c("adh", "us"),
  adh = "us",
  ar1 = c("ad", "adh", "ar1h", "toep", "toeph", "us"),
  ar1h = c("adh", "toeph", "us"),
  cs = c("csh", "toep", "toeph", "us"),
  csh = c("toeph", "us"),
  toep = c("toeph", "us"),
  toeph = "us",
  us = character(0L),
  sp_exp = character(0L)
)
```

Note that since `sp_exp` is a valid covariance structure in `mmrm`, `anova.mmrm()` could encounter it. Therefore, it is included in this `list` object.
