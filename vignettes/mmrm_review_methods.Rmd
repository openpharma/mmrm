---
title: "Implementations of MMRM: a comparison of what's available"
package: mmrm
bibliography: mmrm_review_refs.bib
output:
  rmarkdown::html_document:
          theme: "spacelab"
          highlight: "kate"
          toc: true
          toc_float: true
          toc_depth: 2
vignette: |
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Implementations of MMRM: a comparison of what's available}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
  markdown:
    wrap: 72
---

# Introduction

In this vignette we briefly compare the `mmrm::mmrm`, SAS's `PROC MIXED`,
`nlme::gls`, `lme4::lmer`, and `glmmTMB::glmmTMB` functions for for fitting
mixed models for repeated measures (MMRMs). A primary difference in these
implementations lies in their supported covariance structures. In particular,
`PROC MIXED` and `mmrm` are the only procedures which provide support for many
of the most common MMRM covariance structures. `gls`, `lmer` and `glmmTMB` are
more limited. We find that `mmmrm` converges more quickly than other R
implementations. All implementations are also shown to produce similar marginal
treatment effect estimates.

# Dataset

The FEV dataset contains measurements of FEV1 (forced expired volume in one
second), a measure of how quickly the lungs can be emptied. Low levels of FEV1
may indicate chronic obstructive pulmonary disease (COPD). This data set is used
to illustrate model fitting with the `mmrm`, `lme4`, `nlme`, `glmmTMB` R
packages as well as `PROC MIXED`. It is summarized below.

```
                                      Stratified by ARMCD
                               Overall       PBO           TRT           
  n                              800           420           380        
  USUBJID 
     PT[1-200]                   800           420           380  
  AVISIT (%)                                                             
     VIS1                        200 (25.0)    105 (25.0)     95 ( 25.0) 
     VIS2                        200 (25.0)    105 (25.0)     95 ( 25.0) 
     VIS3                        200 (25.0)    105 (25.0)     95 ( 25.0) 
     VIS4                        200 (25.0)    105 (25.0)     95 ( 25.0) 
  ARMCD = TRT (%)                380 (47.5)      0 ( 0.0)    380 (100.0) 
  RACE (%)                                                               
     Asian                       280 (35.0)    152 (36.2)    128 ( 33.7) 
     Black or African American   300 (37.5)    184 (43.8)    116 ( 30.5) 
     White                       220 (27.5)     84 (20.0)    136 ( 35.8) 
  SEX = Female (%)               424 (53.0)    220 (52.4)    204 ( 53.7) 
  FEV1_BL (mean (SD))          40.19 (9.12)  40.46 (8.84)  39.90 (9.42)  
  FEV1 (mean (SD))             42.30 (9.32)  40.24 (8.67)  44.45 (9.51)  
  WEIGHT (mean (SD))            0.52 (0.23)   0.52 (0.23)   0.51 (0.23)  
  VISITN (mean (SD))            2.50 (1.12)   2.50 (1.12)   2.50 (1.12)  
  VISITN2 (mean (SD))          -0.02 (1.03)   0.01 (1.07)  -0.04 (0.98)  
```

# Model Implementations {.tabset}

Listed below are some of the most commonly used covariance structures used when
fitting MMRMs. We emphasize that this table is not exhaustive; `PROC MIXED` and
`glmmTMB` support additional spatial covariance structures.

| Covariance structures             | `mmrm` | `PROC MIXED` | `gls` | `lmer` | `glmmTMB` |
|:---------------------------------:|:------:|:------------:|:-----:|:------:|:---------:|
| Ante-dependence (heterogeneous)   | X      | X            |       |        |           |
| Ante-dependence (homogeneous)     | X      |              |       |        |           |
| Auto-regressive (heterogeneous)   | X      | X            | X     |        |           |
| Auto-regressive (homogeneous)     | X      | X            |       |        | X         |
| Ante-dependence (homogeneous)     | X      |              |       |        |           |
| Compound symmetry (heterogeneous) | X      | X            | X     |        | X         |
| Compound symmetry (homogeneous)   | X      | X            |       |        |           |
| Spatial exponential               | X      | X            | X     |        | X         |
| Toeplitz (heterogeneous)          | X      | X            |       |        | X         |
| Toeplitz (homogeneous)            | X      | X            |       |        |           |
| Unstructured                      | X      | X            | X     | X      | X         |

Code for fitting MMRMs using each of the considered functions and covariance
structures are provided below. Fixed effects for the visit number, treatment
assignment and the interaction between the two are modeled.

## Ante-dependence (heterogeneous)

### `PROC MIXED`
<pre><code>PROC MIXED DATA = fev_data cl method=ml;
CLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;
MODEL FEV1 = AVISIT|ARMCD / ddfm=satterthwaite solution chisq;
<b>REPEATED AVISIT / subject=USUBJID type=ANTE(1)</b> r=1, 2, 3, 4, 5, 6, 7, 8, 9, 10 rcorr;
</code></pre>

### `mmrm`
<pre><code>mmrm(
  formula = FEV1 ~ ARMCD * AVISIT + <b>adh(VISITN | USUBJID)</b>,
  data = fev_data
)
</code></pre>

## Ante-dependence (homogeneous)

### `mmrm`
<pre><code>mmrm(
  formula =FEV1 ~ ARMCD * AVISIT + <b>ad(VISITN | USUBJID)</b>,
  data = fev_data
)
</code></pre>

## Auto-regressive (heterogeneous)

### `PROC MIXED`
<pre><code>PROC MIXED DATA = fev_data cl method=ml;
CLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;
MODEL FEV1 = AVISIT|ARMCD / ddfm=satterthwaite solution chisq;
<b>REPEATED AVISIT / subject=USUBJID type=ARH(1)</b> r=1, 2, 3, 4, 5, 6, 7, 8, 9, 10 rcorr;
</code></pre>

### `mmrm`
<pre><code>mmrm(
  formula = FEV1 ~ ARMCD * AVISIT + <b>ar1h(VISITN | USUBJID)</b>,
  data = fev_data
)
</code></pre>

### `gls`
<pre><code>gls(
  formula = FEV1 ~ ARMCD * AVISIT,
  data = fev_data,
  correlation = <b>corCAR1(form = ~AVISIT | USUBJID)</b>,
  weights = varIdent(form = ~1|AVISIT),
  na.action = na.omit
)
</code></pre>

## Auto-regressive (homogeneous)

### `PROC MIXED`
<pre><code>PROC MIXED DATA = fev_data cl method=ml;
CLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;
MODEL FEV1 =  ARMCD|AVISIT / ddfm=satterthwaite solution chisq;
<b>REPEATED AVISIT / subject=USUBJID type=AR(1)</b> r=1, 2, 3, 4, 5, 6, 7, 8, 9, 10 rcorr;
</code></pre>

### `mmrm`
<pre><code>mmrm(
  formula = FEV1 ~ ARMCD * AVISIT + <b>ar1(VISITN | USUBJID)</b>,
  data = fev_data
)
</code></pre>

### `glmmTMB`
<pre><code>glmmTMB(
  FEV1 ~ ARMCD * AVISIT + <b>ar1(0 + AVISIT | USUBJID)</b>,
  <b>dispformula = ~ 0</b>,
  data = fev_data
)
</code></pre>

## Compound symmetry (heterogeneous)

### `PROC MIXED`
<pre><code>PROC MIXED DATA = fev_data cl method=ml;
CLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;
MODEL FEV1 = AVISIT|ARMCD / ddfm=satterthwaite solution chisq;
<b>REPEATED AVISIT / subject=USUBJID type=CSH</b> r=1, 2, 3, 4, 5, 6, 7, 8, 9, 10 rcorr;
</code></pre>

### `mmrm`
<pre><code>mmrm(
  formula = FEV1 ~ ARMCD * AVISIT + <b>csh(VISITN | USUBJID)</b>,
  data = fev_data
)
</code></pre>

### `gls`
<pre><code>gls(
  formula = FEV1 ~ ARMCD * AVISIT,
  data = fev_data,
  correlation = <b>corCompSymm(form = ~AVISIT | USUBJID)</b>,
  weights = varIdent(form = ~1|AVISIT),
  na.action = na.omit
)
</code></pre>

### `glmmTMB`
<pre><code>glmmTMB(
  FEV1 ~ ARMCD * AVISIT + <b>cs(0 + AVISIT | USUBJID)</b>,
  <b>dispformula = ~ 0</b>,
  data = fev_data
)
</code></pre>

## Compound symmetry (homogeneous)

### `PROC MIXED`
<pre><code>PROC MIXED DATA = fev_data cl method=ml;
CLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;
MODEL FEV1 = AVISIT|ARMCD / ddfm=satterthwaite solution chisq;
<b>REPEATED AVISIT / subject=USUBJID type=CS</b> r=1, 2, 3, 4, 5, 6, 7, 8, 9, 10 rcorr;
</code></pre>

### `mmrm`
<pre><code>mmrm(
  formula = FEV1 ~ ARMCD * AVISIT + <b>cs(VISITN | USUBJID)</b>,
  data = fev_data
)
</code></pre>

## Spatial exponential

### `PROC MIXED` 
<pre><code>PROC MIXED DATA = fev_data cl method=ml;
CLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;
MODEL FEV1 = AVISIT|ARMCD / ddfm=satterthwaite solution chisq;
<b>REPEATED / subject=USUBJID type=sp(exp)(visitn)</b> rcorr;
</code></pre>

### `mmrm`
<pre><code>mmrm(
  formula = FEV1 ~ ARMCD * AVISIT + <b>sp_exp(VISITN | USUBJID)</b>,
  data = fev_data
)
</code></pre>

### `gls`
<pre><code>gls(
  formula = FEV1 ~ ARMCD * AVISIT,
  data = fev_data,
  correlation = <b>corExp(form = ~AVISIT | USUBJID)</b>,
  weights = varIdent(form = ~1|AVISIT),
  na.action = na.omit
)
</code></pre>

### `glmmTMB`
<pre><code># NOTE: requires use of coordinates
glmmTMB(
  FEV1 ~ ARMCD * AVISIT + <b>exp(0 + AVISIT | USUBJID)</b>,
  <b>dispformula = ~ 0</b>,
  data = fev_data
)
</code></pre>

## Toeplitz (heterogeneous)

### `PROC MIXED`
<pre><code>PROC MIXED DATA = fev_data cl method=ml;
CLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;
MODEL FEV1 = AVISIT|ARMCD / ddfm=satterthwaite solution chisq;
<b>REPEATED AVISIT / subject=USUBJID type=TOEPH</b> r=1, 2, 3, 4, 5, 6, 7, 8, 9, 10 rcorr;
</code></pre>

### `mmrm`
<pre><code>mmrm(
  formula = FEV1 ~ ARMCD * AVISIT + <b>toeph(AVISIT | USUBJID)</b>,
  data = fev_data
)
</code></pre>

### `glmmTMB`
<pre><code> glmmTMB(
  FEV1 ~ ARMCD * AVISIT + <b>toep(0 + AVISIT | USUBJID)</b>,
  <b>dispformula = ~ 0</b>,
  data = fev_data
)
</code></pre>

## Toeplitz (homogeneous)

### `PROC MIXED`
<pre><code>PROC MIXED DATA = fev_data cl method=ml;
CLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;
MODEL FEV1 = AVISIT|ARMCD / ddfm=satterthwaite solution chisq;
<b>REPEATED AVISIT / subject=USUBJID</b> <b>type=TOEP</b> r=1, 2, 3, 4, 5, 6, 7, 8, 9, 10 rcorr;
</code></pre>

### `mmrm`
<pre><code>mmrm(
  formula = FEV1 ~ ARMCD * AVISIT + <b>toep(AVISIT | USUBJID)</b>,
  data = fev_data
)
</code></pre>

## Unstructured

### `PROC MIXED`
<pre><code>PROC MIXED DATA = fev_data cl method=ml;
CLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;
MODEL FEV1 = ARMCD|AVISIT / ddfm=satterthwaite solution chisq;
<b>REPEATED AVISIT / subject=USUBJID</b> <b>type=un</b> r=1, 2, 3, 4, 5, 6, 7, 8, 9, 10 rcorr;
</code></pre>
  
### `mmrm`
<pre><code>mmrm(
  formula = FEV1 ~ ARMCD * AVISIT + <b>us(AVISIT | USUBJID)</b>,
  data = fev_data
)
</code></pre>
  
### `gls`
<pre><code>gls(
  formula = FEV1 ~  ARMCD * AVISIT,
  data = fev_data,
  correlation = <b>corSymm(form = ~AVISIT | USUBJID)</b>,
  weights = varIdent(form = ~1|AVISIT),
  na.action = na.omit
)
</code></pre>

### `lmer`
<pre><code>lmer(
  FEV1 ~ ARMCD * AVISIT + <b>(0 + AVISIT | USUBJID)</b>,
  data = fev_data,
  control = lmerControl(check.nobs.vs.nRE = "ignore"),
  na.action = na.omit
)
</code></pre>

### `glmmTMB`
<pre><code>glmmTMB(
  FEV1 ~ ARMCD * AVISIT + <b>us(0 + AVISIT | USUBJID)</b>,
  <b>dispformula = ~ 0</b>,
  data = fev_data
)
</code></pre>


# Benchmarking

Next, the MMRM fitting procedures are compared. FEV1 measurements are modeled as
a function of race, treatment arm, visit number, and the interaction between the
treatment arm and the visit number. The repeated measures are modeled using an
unstructured covariance matrix. The implementations' convergence times are
evaluated first, followed by a comparison of their estimates.

## Convergence Times

```{r, warning=FALSE, message=FALSE, include=FALSE, echo=FALSE, eval=FALSE}
library(microbenchmark)
library(dplyr)
library(stringr)
library(mmrm)
library(lme4)
library(nlme)
library(glmmTMB)
library(sasr)

# set the number of replicates
n_reps <- 100

# assess convergence times for R-based MMRM procedures
mb <- microbenchmark(times = n_reps,
  gls = gls(
    FEV1 ~ RACE + ARMCD * AVISIT, data = fev_data,
    na.action = na.omit,
    correlation = nlme::corSymm(form = ~ VISITN | USUBJID),
    weights = nlme::varIdent(form = ~ 1|VISITN)
  ),
  mmrm = mmrm(
    formula = FEV1 ~ RACE + ARMCD * AVISIT + us(AVISIT | USUBJID),
    data = fev_data
  ),
  lmer = lmer(
    FEV1 ~ RACE + ARMCD * AVISIT + (0 + AVISIT | USUBJID),
    data = fev_data,
    control = lmerControl(check.nobs.vs.nRE = "ignore"),
    na.action = na.omit
  ),
  glmmTMB = glmmTMB(
    FEV1 ~ RACE + ARMCD * AVISIT + us(0 + AVISIT | USUBJID),
    data = fev_data,
    dispformula = ~ 0,
    REML = TRUE
  )
 )

# construct the partial results table based on R-based MMRM procedures
partial_conv_time_tbl <- mb %>%
  summary() %>%
  arrange(median) %>%
  select(expression = expr, median, lower = lq, upper = uq, evaluations = neval)

# fit PROC MIXED 10 times, extract convergence times
fit_times <- sapply(
  seq_len(n_reps),
  function(x) {
    # load the data into SAS
    df2sd(fev_data, "fev_data")

    sas_code <- "
      PROC MIXED DATA = fev_data cl method=reml;
        CLASS AVISIT(ref = 'VIS1') RACE(ref = 'Asian') ARMCD(ref = 'PBO') USUBJID;
        MODEL FEV1 = RACE ARMCD AVISIT ARMCD*AVISIT / ddfm=satterthwaite solution chisq;
        REPEATED AVISIT / subject=USUBJID type=un r rcorr;
     RUN;
    "

    # generate the SAS output
    sas_result <- run_sas(sas_code)

    # extract the fit time (seconds)
    fit_time <- sas_result$LOG %>%
      str_extract("(?<=real time)\\s*[0-9.]+") %>%
      as.numeric()

    # convert fit times from seconds to milliseconds
    fit_time * 1000
  }
)

# add PROC MIXED results to convergence results table
proc_mixed_row <- tibble(
  expression = "PROC MIXED",
  median = median(fit_times),
  lower = quantile(fit_times, probs = 0.25),
  upper = quantile(fit_times, probs = 0.75),
  evaluations = n_reps
)
conv_time_tbl <- bind_rows(partial_conv_time_tbl, proc_mixed_row)

# format table in markdown
conv_time_tbl %>%
  knitr::kable(caption = "Comparison of convergence times: milliseconds", digits = 2)
```

The `mmrm`, `PROC MIXED`, `gls`, `lmer`, and `glmmTMB` functions are applied to
the FEV dataset 100 times. The convergence times are recorded for each replicate
and are reported in the table below.

Table: Comparison of convergence times (milliseconds)

| Implementation | Median | Lower Quartile | Upper Quartile |
|:---------------|-------:|---------------:|---------------:|
| `PROC MIXED`   |  20.00 |          20.00 |          20.00 |
| `mmrm`         |  50.80 |          50.48 |          51.45 |
| `lmer`         |  97.35 |          96.81 |          97.83 |
| `glmmTMB`      | 273.45 |         271.77 |         275.28 |
| `gls`          | 342.08 |         340.57 |         344.04 |

It is clear from these results that `mmrm` converges significantly faster than
other R functions. Though not demonstrated here, this is generally true
regardless of the sample size and covariance structure used. `PROC MIXED` is the
fastest procedure on average, however.

## Marginal Treatment Effect Estimates Comparison

We next estimate the marginal mean treatment effects for each visit using the
fitted MMRMs. All R implementations' estimates are reported relative to `PROC
MIXED`'s estimates.

```{r, echo = FALSE, warning = FALSE, message = FALSE}
library(dplyr)
library(mmrm)
library(lme4)
library(nlme)
library(glmmTMB)
library(emmeans)
library(sasr)
library(ggplot2)

set.seed(612313)

# compute marginal estimates for mmrm
mmrm_fit <- mmrm(
    formula = FEV1 ~ RACE + ARMCD * AVISIT + us(AVISIT | USUBJID),
    data = fev_data
  )
mmrm_ests <- as.data.frame(
  emmeans(
    mmrm_fit,
    spec = trt.vs.ctrl ~ ARMCD | AVISIT,
    weights = "proportional"
  )$contrasts
)$estimate

# compute marginal estimates for lmer
lmer_fit <- lmer(
  FEV1 ~ RACE + ARMCD * AVISIT + (0 + AVISIT | USUBJID),
  data = fev_data[complete.cases(fev_data), ],
  control = lmerControl(check.nobs.vs.nRE = "ignore")
)
lmer_ests <- as.data.frame(
  emmeans(
    lmer_fit,
    spec = trt.vs.ctrl ~ ARMCD | AVISIT,
    data = fev_data[complete.cases(fev_data), ],
    weights = "proportional"
  )$contrasts
)$estimate

# compute marginal estimates for gls
gls_fit <- gls(
  FEV1 ~ RACE + ARMCD * AVISIT, data = fev_data[complete.cases(fev_data), ],
  correlation = nlme::corSymm(form = ~ VISITN | USUBJID),
  weights = nlme::varIdent(form = ~ 1|VISITN)
)
gls_ests <- as.data.frame(
  emmeans(
    gls_fit,
    spec = trt.vs.ctrl ~ ARMCD | AVISIT,
    data = fev_data[complete.cases(fev_data), ],
    weights = "proportional",
    mode = "df.error"
  )$contrasts
)$estimate

# compute marginal estimates for glmmTMB
glmmTMB_fit <- glmmTMB(
  FEV1 ~ RACE + ARMCD * AVISIT + us(0 + AVISIT | USUBJID),
  data = fev_data,
  dispformula = ~ 0
)
glmmTMB_ests <- as.data.frame(
  emmeans(
    glmmTMB_fit,
    spec = trt.vs.ctrl ~ ARMCD | AVISIT,
    weights = "proportional"
  )$contrasts
)$estimate

## # compute marginal estimates from PROC MIXED
## # load the data into SAS
## df2sd(fev_data, "fev_data")

## sas_code <- "ODS OUTPUT LSMEANS = lsmeans_out DIFFS = diffs_out;
##   PROC MIXED DATA = fev_data cl method=reml;
##     CLASS AVISIT(ref = 'VIS1') RACE(ref = 'Asian') ARMCD(ref = 'PBO') USUBJID;
##     MODEL FEV1 = ARMCD AVISIT ARMCD*AVISIT RACE / ddfm=satterthwaite solution chisq;
##     REPEATED AVISIT / subject=USUBJID type=un r rcorr;
##     LSMEANS ARMCD*AVISIT / pdiff slice=AVISIT cl alpha = 0.05 OBSMARGINS;
##   RUN;
## "

## # generate the SAS output
## sas_result <- run_sas(sas_code)

## ## extract the ATEs across visits
## ates_df <- sd2df("diffs_out") %>%
##   filter(AVISIT == `_AVISIT`) %>%
##   mutate(
##       contrast = paste0(AVISIT, ": ", ARMCD, " - ", `_ARMCD`)
##   ) %>%
##   select(contrast, Estimate, StdErr, DF, tValue, Lower, Upper) %>%
##   arrange(contrast)

## proc_mixed_ests <- ates_df$Estimate
proc_mixed_ests <- c(3.775614, 3.758119, 3.108027, 4.406510)

# compute the relative differences
rel_diff <- function(ests) (ests - proc_mixed_ests) / proc_mixed_ests

# construct table for plotting
rel_diff_ests_tbl <- tibble(
  parameter = factor(rep(c("Visit 1", "Visit 2", "Visit 3", "Visit 4"), 4)),
  estimator = rep(c("mmrm", "lmer", "gls", "glmmTMB"), each = 4),
  rel_diff = c(
    rel_diff(mmrm_ests), rel_diff(lmer_ests), rel_diff(gls_ests),
    rel_diff(glmmTMB_ests)
  )
)

# plot estimates
rel_diff_ests_tbl %>%
  ggplot(aes(x = parameter, y = rel_diff, color = estimator)) +
    geom_point(position = position_dodge(width = 0.5)) +
    geom_hline(yintercept = 0, linetype = 2, alpha = 0.5) +
    scale_color_discrete(name = "Procedure") +
    ylab("Relative Difference") +
    xlab("Marginal Treatment Effect") +
    ggtitle("Average Treatment Effect Estimates Relative to SAS Estimates") +
    theme_classic()
```

The R procedures' estimates are very similar to those output by `PROC MIXED`,
though `mmrm` and `gls` generate the estimates that are closest to those
produced when using SAS.
