---
title: "Implementations of MMRM: a comparison of what's available"
package: mmrm
bibliography: mmrm_review_refs.bib
output:
  rmarkdown::html_document:
          theme: "spacelab"
          highlight: "kate"
          toc: true
          toc_float: true
          toc_depth: 2
vignette: |
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Implementations of MMRM: a comparison of what's available}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
  markdown:
    wrap: 72
---

```{r setup, message=FALSE, warning=FALSE, include=FALSE}
library(MASS)
library(clusterGeneration)
library(dplyr)
library(purrr)
library(microbenchmark)
library(stringr)
library(mmrm)
library(lme4)
library(nlme)
library(glmmTMB)
library(sasr)
library(knitr)
library(emmeans)
library(ggplot2)

set.seed(5123)
```

# Introduction

In this vignette we briefly compare the `mmrm::mmrm`, SAS's `PROC MIXED`,
`nlme::gls`, `lme4::lmer`, and `glmmTMB::glmmTMB` functions for fitting mixed
models for repeated measures (MMRMs). A primary difference in these
implementations lies in the covariance structures that are supported "out of the
box". In particular, `PROC MIXED` and `mmrm` are the only procedures which
provide support for many of the most common MMRM covariance structures. Most
covariance structures can be implemented in `gls`, though users are required to
define them manually. `lmer` and `glmmTMB` are more limited. We find that
`mmmrm` converges more quickly than other R implementations while also producing
estimates that are virtually identical to `PROC MIXED`'s.

# Datasets

Two datasets are used to illustrate model fitting with the `mmrm`, `lme4`,
`nlme`, `glmmTMB` R packages as well as `PROC MIXED`. These data are also used
to compare these implementations' operating characteristics.

## FEV Data

The FEV dataset contains measurements of FEV1 (forced expired volume in one
second), a measure of how quickly the lungs can be emptied. Low levels of FEV1
may indicate chronic obstructive pulmonary disease (COPD). It is summarized below.

```
                                      Stratified by ARMCD
                               Overall       PBO           TRT
  n                              800           420           380
  USUBJID (%)
     PT[1-200]                   200           105 (52.5)     95 (47.5)
  AVISIT
     VIS1                        200           105            95
     VIS2                        200           105            95
     VIS3                        200           105            95
     VIS4                        200           105            95
  RACE (%)
     Asian                       280 (35.0)    152 (36.2)    128 (33.7)
     Black or African American   300 (37.5)    184 (43.8)    116 (30.5)
     White                       220 (27.5)     84 (20.0)    136 (35.8)
  SEX = Female (%)               424 (53.0)    220 (52.4)    204 (53.7)
  FEV1_BL (mean (SD))          40.19 (9.12)  40.46 (8.84)  39.90 (9.42)
  FEV1 (mean (SD))             42.30 (9.32)  40.24 (8.67)  44.45 (9.51)
  WEIGHT (mean (SD))            0.52 (0.23)   0.52 (0.23)   0.51 (0.23)
  VISITN (mean (SD))            2.50 (1.12)   2.50 (1.12)   2.50 (1.12)
  VISITN2 (mean (SD))          -0.02 (1.03)   0.01 (1.07)  -0.04 (0.98)
```

## BCVA Data

The BCVA dataset contains data from a randomized longitudinal ophthalmology
trial evaluating the change in baseline corrected visual acuity (BCVA) over the
course of 10 visits. BCVA corresponds to the number of letters read from a
visual acuity chart. A summary of the data is given below:

```
                                      Stratified by ARMCD
                               Overall         CTL            TRT
  n                             8605          4123           4482
  USUBJID (%)
     PT[1-1000]                 1000           494 (49.4)     506 (50.6)
  AVISIT
     VIS1                        983           482            501
     VIS2                        980           481            499
     VIS3                        960           471            489
     VIS4                        946           458            488
     VIS5                        925           454            471
     VIS6                        868           410            458
     VIS7                        816           388            428
     VIS8                        791           371            420
     VIS9                        719           327            392
     VIS10                       617           281            336
  RACE (%)
     Asian                       297 (29.7)    151 (30.6)     146 (28.9)
     Black or African American   317 (31.7)    149 (30.1)     168 (33.2)
     White                       386 (38.6)    194 (39.3)     192 (37.9)
  BCVA_BL (mean (SD))          75.12 (9.93)  74.90 (9.76)   75.40 (10.1)
  BCVA_CHG (mean (SD))
     VIS1                       5.59 (1.31)   5.32 (1.23)    5.86 (1.33)
     VIS10                      9.18 (2.91)   7.49 (2.58)   10.60 (2.36)
```



# Model Implementations {.tabset}

Listed below are some of the most commonly used covariance structures used when
fitting MMRMs. We indicate which matrices are available "out of the box" for
each implementation considered in this vignette. Note that this table is not
exhaustive; `PROC MIXED` and `glmmTMB` support additional spatial covariance
structures.

| Covariance structures             | `mmrm` | `PROC MIXED` | `gls` | `lmer` | `glmmTMB` |
|:---------------------------------:|:------:|:------------:|:-----:|:------:|:---------:|
| Ante-dependence (heterogeneous)   | X      | X            |       |        |           |
| Ante-dependence (homogeneous)     | X      |              |       |        |           |
| Auto-regressive (heterogeneous)   | X      | X            | X     |        |           |
| Auto-regressive (homogeneous)     | X      | X            | X     |        | X         |
| Compound symmetry (heterogeneous) | X      | X            | X     |        | X         |
| Compound symmetry (homogeneous)   | X      | X            | X     |        |           |
| Spatial exponential               | X      | X            | X     |        | X         |
| Toeplitz (heterogeneous)          | X      | X            |       |        | X         |
| Toeplitz (homogeneous)            | X      | X            |       |        |           |
| Unstructured                      | X      | X            | X     | X      | X         |

Code for fitting MMRMs to the FEV data using each of the considered functions
and covariance structures are provided below. Fixed effects for the visit
number, treatment assignment and the interaction between the two are modeled.

## Ante-dependence (heterogeneous)

### `PROC MIXED`
<pre><code>PROC MIXED DATA = fev_data cl method=ml;
CLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;
MODEL FEV1 = AVISIT|ARMCD / ddfm=satterthwaite solution chisq;
<b>REPEATED AVISIT / subject=USUBJID type=ANTE(1)</b> r=1, 2, 3, 4, 5, 6, 7, 8, 9, 10 rcorr;
</code></pre>

### `mmrm`
<pre><code>mmrm(
  formula = FEV1 ~ ARMCD * AVISIT + <b>adh(VISITN | USUBJID)</b>,
  data = fev_data
)
</code></pre>

## Ante-dependence (homogeneous)

### `mmrm`
<pre><code>mmrm(
  formula =FEV1 ~ ARMCD * AVISIT + <b>ad(VISITN | USUBJID)</b>,
  data = fev_data
)
</code></pre>

## Auto-regressive (heterogeneous)

### `PROC MIXED`
<pre><code>PROC MIXED DATA = fev_data cl method=ml;
CLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;
MODEL FEV1 = AVISIT|ARMCD / ddfm=satterthwaite solution chisq;
<b>REPEATED AVISIT / subject=USUBJID type=ARH(1)</b> r=1, 2, 3, 4, 5, 6, 7, 8, 9, 10 rcorr;
</code></pre>

### `mmrm`
<pre><code>mmrm(
  formula = FEV1 ~ ARMCD * AVISIT + <b>ar1h(VISITN | USUBJID)</b>,
  data = fev_data
)
</code></pre>

### `gls`
<pre><code>gls(
  formula = FEV1 ~ ARMCD * AVISIT,
  data = fev_data,
  correlation = <b>corCAR1(form = ~AVISIT | USUBJID)</b>,
  weights = <b>varIdent(form = ~1|AVISIT)</b>,
  na.action = na.omit
)
</code></pre>

## Auto-regressive (homogeneous)

### `PROC MIXED`
<pre><code>PROC MIXED DATA = fev_data cl method=ml;
CLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;
MODEL FEV1 =  ARMCD|AVISIT / ddfm=satterthwaite solution chisq;
<b>REPEATED AVISIT / subject=USUBJID type=AR(1)</b> r=1, 2, 3, 4, 5, 6, 7, 8, 9, 10 rcorr;
</code></pre>

### `mmrm`
<pre><code>mmrm(
  formula = FEV1 ~ ARMCD * AVISIT + <b>ar1(VISITN | USUBJID)</b>,
  data = fev_data
)
</code></pre>

### `gls`
<pre><code>gls(
  formula = FEV1 ~ ARMCD * AVISIT,
  data = fev_data,
  correlation = <b>corCAR1(form = ~AVISIT | USUBJID)</b>,
  na.action = na.omit
)
</code></pre>

### `glmmTMB`
<pre><code>glmmTMB(
  FEV1 ~ ARMCD * AVISIT + <b>ar1(0 + AVISIT | USUBJID)</b>,
  <b>dispformula = ~ 0</b>,
  data = fev_data
)
</code></pre>

## Compound symmetry (heterogeneous)

### `PROC MIXED`
<pre><code>PROC MIXED DATA = fev_data cl method=ml;
CLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;
MODEL FEV1 = AVISIT|ARMCD / ddfm=satterthwaite solution chisq;
<b>REPEATED AVISIT / subject=USUBJID type=CSH</b> r=1, 2, 3, 4, 5, 6, 7, 8, 9, 10 rcorr;
</code></pre>

### `mmrm`
<pre><code>mmrm(
  formula = FEV1 ~ ARMCD * AVISIT + <b>csh(VISITN | USUBJID)</b>,
  data = fev_data
)
</code></pre>

### `gls`
<pre><code>gls(
  formula = FEV1 ~ ARMCD * AVISIT,
  data = fev_data,
  correlation = <b>corCompSymm(form = ~AVISIT | USUBJID)</b>,
  weights = <b>varIdent(form = ~1|AVISIT)</b>,
  na.action = na.omit
)
</code></pre>

### `glmmTMB`
<pre><code>glmmTMB(
  FEV1 ~ ARMCD * AVISIT + <b>cs(0 + AVISIT | USUBJID)</b>,
  <b>dispformula = ~ 0</b>,
  data = fev_data
)
</code></pre>

## Compound symmetry (homogeneous)

### `PROC MIXED`
<pre><code>PROC MIXED DATA = fev_data cl method=ml;
CLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;
MODEL FEV1 = AVISIT|ARMCD / ddfm=satterthwaite solution chisq;
<b>REPEATED AVISIT / subject=USUBJID type=CS</b> r=1, 2, 3, 4, 5, 6, 7, 8, 9, 10 rcorr;
</code></pre>

### `mmrm`
<pre><code>mmrm(
  formula = FEV1 ~ ARMCD * AVISIT + <b>cs(VISITN | USUBJID)</b>,
  data = fev_data
)
</code></pre>

### `gls`
<pre><code>gls(
  formula = FEV1 ~ ARMCD * AVISIT,
  data = fev_data,
  correlation = <b>corCompSymm(form = ~AVISIT | USUBJID)</b>,
  na.action = na.omit
)
</code></pre>


## Spatial exponential

### `PROC MIXED`
<pre><code>PROC MIXED DATA = fev_data cl method=ml;
CLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;
MODEL FEV1 = AVISIT|ARMCD / ddfm=satterthwaite solution chisq;
<b>REPEATED / subject=USUBJID type=sp(exp)(visitn)</b> rcorr;
</code></pre>

### `mmrm`
<pre><code>mmrm(
  formula = FEV1 ~ ARMCD * AVISIT + <b>sp_exp(VISITN | USUBJID)</b>,
  data = fev_data
)
</code></pre>

### `gls`
<pre><code>gls(
  formula = FEV1 ~ ARMCD * AVISIT,
  data = fev_data,
  correlation = <b>corExp(form = ~AVISIT | USUBJID)</b>,
  weights = varIdent(form = ~1|AVISIT),
  na.action = na.omit
)
</code></pre>

### `glmmTMB`
<pre><code># NOTE: requires use of coordinates
glmmTMB(
  FEV1 ~ ARMCD * AVISIT + <b>exp(0 + AVISIT | USUBJID)</b>,
  <b>dispformula = ~ 0</b>,
  data = fev_data
)
</code></pre>

## Toeplitz (heterogeneous)

### `PROC MIXED`
<pre><code>PROC MIXED DATA = fev_data cl method=ml;
CLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;
MODEL FEV1 = AVISIT|ARMCD / ddfm=satterthwaite solution chisq;
<b>REPEATED AVISIT / subject=USUBJID type=TOEPH</b> r=1, 2, 3, 4, 5, 6, 7, 8, 9, 10 rcorr;
</code></pre>

### `mmrm`
<pre><code>mmrm(
  formula = FEV1 ~ ARMCD * AVISIT + <b>toeph(AVISIT | USUBJID)</b>,
  data = fev_data
)
</code></pre>

### `glmmTMB`
<pre><code> glmmTMB(
  FEV1 ~ ARMCD * AVISIT + <b>toep(0 + AVISIT | USUBJID)</b>,
  <b>dispformula = ~ 0</b>,
  data = fev_data
)
</code></pre>

## Toeplitz (homogeneous)

### `PROC MIXED`
<pre><code>PROC MIXED DATA = fev_data cl method=ml;
CLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;
MODEL FEV1 = AVISIT|ARMCD / ddfm=satterthwaite solution chisq;
<b>REPEATED AVISIT / subject=USUBJID</b> <b>type=TOEP</b> r=1, 2, 3, 4, 5, 6, 7, 8, 9, 10 rcorr;
</code></pre>

### `mmrm`
<pre><code>mmrm(
  formula = FEV1 ~ ARMCD * AVISIT + <b>toep(AVISIT | USUBJID)</b>,
  data = fev_data
)
</code></pre>

## Unstructured

### `PROC MIXED`
<pre><code>PROC MIXED DATA = fev_data cl method=ml;
CLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;
MODEL FEV1 = ARMCD|AVISIT / ddfm=satterthwaite solution chisq;
<b>REPEATED AVISIT / subject=USUBJID</b> <b>type=un</b> r=1, 2, 3, 4, 5, 6, 7, 8, 9, 10 rcorr;
</code></pre>

### `mmrm`
<pre><code>mmrm(
  formula = FEV1 ~ ARMCD * AVISIT + <b>us(AVISIT | USUBJID)</b>,
  data = fev_data
)
</code></pre>

### `gls`
<pre><code>gls(
  formula = FEV1 ~  ARMCD * AVISIT,
  data = fev_data,
  correlation = <b>corSymm(form = ~AVISIT | USUBJID)</b>,
  weights = varIdent(form = ~1|AVISIT),
  na.action = na.omit
)
</code></pre>

### `lmer`
<pre><code>lmer(
  FEV1 ~ ARMCD * AVISIT + <b>(0 + AVISIT | USUBJID)</b>,
  data = fev_data,
  control = lmerControl(check.nobs.vs.nRE = "ignore"),
  na.action = na.omit
)
</code></pre>

### `glmmTMB`
<pre><code>glmmTMB(
  FEV1 ~ ARMCD * AVISIT + <b>us(0 + AVISIT | USUBJID)</b>,
  <b>dispformula = ~ 0</b>,
  data = fev_data
)
</code></pre>


# Benchmarking

Next, the MMRM fitting procedures are compared using the FEV and BCVA datasets.
FEV1 measurements are modeled as a function of race, treatment arm, visit
number, and the interaction between the treatment arm and the visit number.
Change in BCVA is assumed to be a function of race, baseline BCVA, treatment
arm, visit number, and the treatment--visit interaction. In both datasets,
repeated measures are modeled using an unstructured covariance matrix. The
implementations' convergence times are evaluated first, followed by a comparison
of their estimates. Finally, we fit these procedures on simulated BCVA-like data
to assess the impact of missingness on convergence rates.

## Convergence Times

### FEV Data

The `mmrm`, `PROC MIXED`, `gls`, `lmer`, and `glmmTMB` functions are applied to
the FEV dataset 10 times. The convergence times are recorded for each replicate
and are reported in the table below.

```{r, warning=FALSE, message=FALSE, echo=FALSE}
# set the number of replicates
n_reps <- 10

# assess convergence times for R-based MMRM procedures
mb <- microbenchmark(
  times = n_reps,
  gls = gls(
    FEV1 ~ RACE + ARMCD * AVISIT,
    data = fev_data,
    na.action = na.omit,
    correlation = nlme::corSymm(form = ~ VISITN | USUBJID),
    weights = nlme::varIdent(form = ~ 1 | VISITN)
  ),
  mmrm = mmrm(
    formula = FEV1 ~ RACE + ARMCD * AVISIT + us(AVISIT | USUBJID),
    data = fev_data
  ),
  lmer = lmer(
    FEV1 ~ RACE + ARMCD * AVISIT + (0 + AVISIT | USUBJID),
    data = fev_data,
    control = lmerControl(check.nobs.vs.nRE = "ignore"),
    na.action = na.omit
  ),
  glmmTMB = glmmTMB(
    FEV1 ~ RACE + ARMCD * AVISIT + us(0 + AVISIT | USUBJID),
    data = fev_data,
    dispformula = ~0,
    REML = TRUE
  )
)

# construct the partial results table based on R-based MMRM procedures
partial_conv_time_tbl <- mb %>%
  summary() %>%
  dplyr::arrange(median) %>%
  dplyr::select(expression = expr, median, lower = lq, upper = uq, evaluations = neval)

# fit PROC MIXED 10 times if a sascfg file exists
if (file.exists("sascfg_personal.py")) {
  fit_times <- sapply(
    seq_len(n_reps),
    function(x) {
      # load the data into SAS
      df2sd(fev_data, "fev_data")

      sas_code <- "
      PROC MIXED DATA = fev_data cl method=reml;
        CLASS AVISIT(ref = 'VIS1') RACE(ref = 'Asian') ARMCD(ref = 'PBO') USUBJID;
        MODEL FEV1 = RACE ARMCD AVISIT ARMCD*AVISIT / ddfm=satterthwaite solution chisq;
        REPEATED AVISIT / subject=USUBJID type=un r rcorr;
     RUN;
    "

      # generate the SAS output
      sas_result <- run_sas(sas_code)

      # extract the fit time (seconds)
      fit_time <- sas_result$LOG %>%
        str_extract("(?<=real time)\\s*[0-9.]+") %>%
        as.numeric()

      # convert fit times from seconds to milliseconds
      fit_time * 1000
    }
  )

  # add PROC MIXED results to convergence results table
  proc_mixed_row <- tibble(
    expression = "PROC MIXED",
    median = median(fit_times),
    lower = quantile(fit_times, probs = 0.25),
    upper = quantile(fit_times, probs = 0.75),
    evaluations = n_reps
  )
  conv_time_tbl <- bind_rows(partial_conv_time_tbl, proc_mixed_row)
} else {
  conv_time_tbl <- partial_conv_time_tbl
}

# format table in markdown
conv_time_tbl %>%
  arrange(median) %>%
  transmute(
    Implementation = expression,
    Median = median,
    `First Quartile` = lower,
    `Third Quartile` = upper
  ) %>%
  knitr::kable(
    caption = "Comparison of convergence times: milliseconds", digits = 2
  )
```

It is clear from these results that `mmrm` converges significantly faster than
other R functions. Though not demonstrated here, this is generally true
regardless of the sample size and covariance structure used. `PROC MIXED` is the
fastest procedure on average, however.

### BCVA Data

The MMRM implementations are now applied to the BCVA dataset 10 times. The
convergence times are presented below.

```{r, warning=FALSE, message=FALSE, echo=FALSE}
# set the number of replicates
n_reps <- 10

# assess convergence times for R-based MMRM procedures
mb <- microbenchmark(
  times = n_reps,
  gls = gls(
    BCVA_CHG ~ BCVA_BL + RACE + ARMCD * AVISIT,
    data = bcva_data,
    na.action = na.omit,
    correlation = nlme::corSymm(form = ~ VISITN | USUBJID),
    weights = nlme::varIdent(form = ~ 1 | VISITN)
  ),
  mmrm = mmrm(
    formula = BCVA_CHG ~ BCVA_BL + RACE + ARMCD * AVISIT + us(AVISIT | USUBJID),
    data = bcva_data
  ),
  lmer = lmer(
    BCVA_CHG ~ BCVA_BL + RACE + ARMCD * AVISIT + (0 + AVISIT | USUBJID),
    data = bcva_data,
    control = lmerControl(check.nobs.vs.nRE = "ignore"),
    na.action = na.omit
  ),
  glmmTMB = glmmTMB(
    BCVA_CHG ~ BCVA_BL + RACE + ARMCD * AVISIT + us(0 + AVISIT | USUBJID),
    data = bcva_data,
    dispformula = ~0,
    REML = TRUE
  )
)

# construct the partial results table based on R-based MMRM procedures
partial_conv_time_tbl <- mb %>%
  summary() %>%
  dplyr::arrange(median) %>%
  dplyr::select(expression = expr, median, lower = lq, upper = uq, evaluations = neval)

# fit PROC MIXED 10 times if a sascfg file exists
if (file.exists("sascfg_personal.py")) {
  fit_times <- sapply(
    seq_len(n_reps),
    function(x) {
      # load the data into SAS
      df2sd(bcva_data, "bcva_data")

      sas_code <- "
      PROC MIXED DATA = bcva_data cl method=reml;
        CLASS AVISIT(ref = 'VIS01') RACE(ref = 'Asian') ARMCD(ref = 'CTL') USUBJID;
        MODEL BCVA_CHG = BCVA_BL RACE ARMCD AVISIT ARMCD*AVISIT / ddfm=satterthwaite solution chisq;
        REPEATED AVISIT / subject=USUBJID type=un r rcorr;
     RUN;
    "

      # generate the SAS output
      sas_result <- run_sas(sas_code)

      # extract the fit time (seconds)
      fit_time <- sas_result$LOG %>%
        str_extract("(?<=real time)\\s*[0-9.]+") %>%
        as.numeric()

      # convert fit times from seconds to milliseconds
      fit_time
    }
  )

  # add PROC MIXED results to convergence results table
  proc_mixed_row <- tibble(
    expression = "PROC MIXED",
    median = median(fit_times),
    lower = quantile(fit_times, probs = 0.25),
    upper = quantile(fit_times, probs = 0.75),
    evaluations = n_reps
  )
  conv_time_tbl <- bind_rows(partial_conv_time_tbl, proc_mixed_row)
} else {
  conv_time_tbl <- partial_conv_time_tbl
}

# format table in markdown
conv_time_tbl %>%
  arrange(median) %>%
  transmute(
    Implementation = expression,
    Median = median,
    `First Quartile` = lower,
    `Third Quartile` = upper
  ) %>%
  knitr::kable(
    caption = "Comparison of convergence times: seconds", digits = 2
  )
```

We again find that `PROC MIXED` produces the fastest convergence times on
average, followed closely by `mmrm`. The latter is the fastest of the R
implementations, just as in the FEV data.

## Marginal Treatment Effect Estimates Comparison

We next estimate the marginal mean treatment effects for each visit in the FEV
and BCVA datasets using the MMRM fitting procedures. All R implementations'
estimates are reported relative to `PROC MIXED`'s estimates. Convergence status
is also reported.

### FEV Data

```{r, echo = FALSE, warning = FALSE, message = FALSE}
# compute marginal estimates for mmrm
mmrm_fit <- mmrm(
  formula = FEV1 ~ RACE + ARMCD * AVISIT + us(AVISIT | USUBJID),
  data = fev_data
)
mmrm_ests <- as.data.frame(
  emmeans(
    mmrm_fit,
    spec = trt.vs.ctrl ~ ARMCD | AVISIT,
    weights = "proportional"
  )$contrasts
)$estimate

# compute marginal estimates for lmer
lmer_fit <- lmer(
  FEV1 ~ RACE + ARMCD * AVISIT + (0 + AVISIT | USUBJID),
  data = fev_data[complete.cases(fev_data), ],
  control = lmerControl(check.nobs.vs.nRE = "ignore")
)
lmer_ests <- as.data.frame(
  emmeans(
    lmer_fit,
    spec = trt.vs.ctrl ~ ARMCD | AVISIT,
    data = fev_data[complete.cases(fev_data), ],
    weights = "proportional"
  )$contrasts
)$estimate

# compute marginal estimates for gls
gls_fit <- gls(
  FEV1 ~ RACE + ARMCD * AVISIT,
  data = fev_data[complete.cases(fev_data), ],
  correlation = nlme::corSymm(form = ~ VISITN | USUBJID),
  weights = nlme::varIdent(form = ~ 1 | VISITN)
)
gls_ests <- as.data.frame(
  emmeans(
    gls_fit,
    spec = trt.vs.ctrl ~ ARMCD | AVISIT,
    data = fev_data[complete.cases(fev_data), ],
    weights = "proportional",
    mode = "df.error"
  )$contrasts
)$estimate

# compute marginal estimates for glmmTMB
glmmtmb_fit <- glmmTMB(
  FEV1 ~ RACE + ARMCD * AVISIT + us(0 + AVISIT | USUBJID),
  data = fev_data,
  dispformula = ~0
)
glmmtmb_ests <- as.data.frame(
  emmeans(
    glmmtmb_fit,
    spec = trt.vs.ctrl ~ ARMCD | AVISIT,
    weights = "proportional"
  )$contrasts
)$estimate

if (file.exists("sascfg_personal.py")) {
  # compute marginal estimates from PROC MIXED
  # load the data into SAS
  df2sd(fev_data, "fev_data")

  sas_code <- "ODS OUTPUT LSMEANS = lsmeans_out DIFFS = diffs_out;
  PROC MIXED DATA = fev_data cl method=reml;
    CLASS AVISIT(ref = 'VIS1') RACE(ref = 'Asian') ARMCD(ref = 'PBO') USUBJID;
    MODEL FEV1 = ARMCD AVISIT ARMCD*AVISIT RACE / ddfm=satterthwaite solution chisq;
    REPEATED AVISIT / subject=USUBJID type=un r rcorr;
    LSMEANS ARMCD*AVISIT / pdiff slice=AVISIT cl alpha = 0.05 OBSMARGINS;
  RUN;
"

  # generate the SAS output
  sas_result <- run_sas(sas_code)

  ## extract the ATEs across visits
  ates_df <- sd2df("diffs_out") %>%
    dplyr::filter(AVISIT == `_AVISIT`) %>%
    dplyr::mutate(
      contrast = paste0(AVISIT, ": ", ARMCD, " - ", `_ARMCD`)
    ) %>%
    dplyr::select(contrast, Estimate, StdErr, DF, tValue, Lower, Upper) %>%
    dplyr::arrange(contrast)

  proc_mixed_ests <- ates_df$Estimate
} else {
  proc_mixed_ests <- c(3.775614, 3.758119, 3.108027, 4.406510)
}

# compute the relative differences
rel_diff <- function(ests) (ests - proc_mixed_ests) / proc_mixed_ests

# construct table for plotting
# NOTE: that convergence is assessed manually here, not all methods provide
# methods for reporting convergence
rel_diff_ests_tbl <- tibble(
  parameter = factor(rep(c("Visit 1", "Visit 2", "Visit 3", "Visit 4"), 4)),
  estimator = rep(c("mmrm", "lmer", "gls", "glmmTMB"), each = 4),
  converged = rep(c(TRUE, TRUE, TRUE, TRUE), each = 4),
  rel_diff = c(
    rel_diff(mmrm_ests), rel_diff(lmer_ests), rel_diff(gls_ests),
    rel_diff(glmmtmb_ests)
  )
) %>%
  mutate(converged = factor(converged, levels = c(TRUE, FALSE)))

# plot estimates
rel_diff_ests_tbl %>%
  ggplot(
    aes(x = parameter, y = rel_diff, color = estimator, shape = converged)
  ) +
  geom_point(position = position_dodge(width = 0.5)) +
  geom_hline(yintercept = 0, linetype = 2, alpha = 0.5) +
  scale_color_discrete(name = "Procedure") +
  scale_shape_discrete(name = "Convergence") +
  ylab("Relative Difference") +
  xlab("Marginal Treatment Effect") +
  ggtitle("Average Treatment Effect Estimates Relative to SAS Estimates") +
  theme_classic()
```

The R procedures' estimates are very similar to those output by `PROC MIXED`,
though `mmrm` and `gls` generate the estimates that are closest to those
produced when using SAS. All methods converge using their default optimization
arguments.

### BCVA Data

```{r, echo = FALSE, warning = FALSE, message = FALSE}
# compute marginal estimates for mmrm
mmrm_fit <- mmrm(
  formula = BCVA_CHG ~ BCVA_BL + RACE + ARMCD * AVISIT + us(AVISIT | USUBJID),
  data = bcva_data
)
mmrm_ests <- as.data.frame(
  emmeans(
    mmrm_fit,
    spec = trt.vs.ctrl ~ ARMCD | AVISIT,
    weights = "proportional"
  )$contrasts
)$estimate

# compute marginal estimates for lmer
lmer_fit <- lmer(
  BCVA_CHG ~ BCVA_BL + RACE + ARMCD * AVISIT + (0 + AVISIT | USUBJID),
  data = bcva_data[complete.cases(bcva_data), ],
  control = lmerControl(check.nobs.vs.nRE = "ignore")
)
lmer_ests <- as.data.frame(
  emmeans(
    lmer_fit,
    spec = trt.vs.ctrl ~ ARMCD | AVISIT,
    data = bcva_data[complete.cases(bcva_data), ],
    weights = "proportional"
  )$contrasts
)$estimate

# compute marginal estimates for gls
gls_fit <- gls(
  BCVA_CHG ~ BCVA_BL + RACE + ARMCD * AVISIT,
  data = bcva_data[complete.cases(bcva_data), ],
  correlation = nlme::corSymm(form = ~ VISITN | USUBJID),
  weights = nlme::varIdent(form = ~ 1 | VISITN)
)
gls_ests <- as.data.frame(
  emmeans(
    gls_fit,
    spec = trt.vs.ctrl ~ ARMCD | AVISIT,
    data = bcva_data[complete.cases(bcva_data), ],
    weights = "proportional",
    mode = "df.error"
  )$contrasts
)$estimate

# compute marginal estimates for glmmTMB
glmmtmb_fit <- glmmTMB(
  BCVA_CHG ~ BCVA_BL + RACE + ARMCD * AVISIT + us(0 + AVISIT | USUBJID),
  data = bcva_data,
  dispformula = ~0
)
glmmtmb_ests <- as.data.frame(
  emmeans(
    glmmtmb_fit,
    spec = trt.vs.ctrl ~ ARMCD | AVISIT,
    weights = "proportional"
  )$contrasts
)$estimate

if (file.exists("sascfg_personal.py")) {
  # compute marginal estimates from PROC MIXED
  # load the data into SAS
  df2sd(bcva_data, "bcva_data")

  sas_code <- "ODS OUTPUT LSMEANS = lsmeans_out DIFFS = diffs_out;
  PROC MIXED DATA = bcva_data cl method=reml;
    CLASS AVISIT(ref = 'VIS01') RACE(ref = 'Asian') ARMCD(ref = 'CTL') USUBJID;
    MODEL BCVA_CHG = BCVA_BL ARMCD AVISIT ARMCD*AVISIT RACE / ddfm=satterthwaite solution chisq;
    REPEATED AVISIT / subject=USUBJID type=un r rcorr;
    LSMEANS ARMCD*AVISIT / pdiff slice=AVISIT cl alpha = 0.05 OBSMARGINS;
  RUN;
"

  # generate the SAS output
  sas_result <- run_sas(sas_code)

  ## extract the ATEs across visits
  ates_df <- sd2df("diffs_out") %>%
    dplyr::filter(AVISIT == `_AVISIT`) %>%
    dplyr::mutate(
      contrast = paste0(AVISIT, ": ", ARMCD, " - ", `_ARMCD`)
    ) %>%
    dplyr::select(contrast, Estimate, StdErr, DF, tValue, Lower, Upper) %>%
    dplyr::arrange(contrast)

  proc_mixed_ests <- ates_df$Estimate
} else {
  proc_mixed_ests <- c(
    0.539107, 0.724779, 1.011511, 1.104181, 1.383358,
    1.630093, 2.015963, 2.346931, 2.658452, 3.072256
  )
}

# compute the relative differences
rel_diff <- function(ests) (ests - proc_mixed_ests) / proc_mixed_ests

# construct table for plotting
# NOTE: that convergence is assessed manually here, not all methods provide
# methods for reporting convergence
rel_diff_ests_tbl <- tibble(
  parameter = factor(rep(c(paste("Visit", seq_len(10))), 4)),
  estimator = rep(c("mmrm", "lmer", "gls", "glmmTMB"), each = 10),
  converged = rep(c(TRUE, FALSE, TRUE, FALSE), each = 10),
  rel_diff = c(
    rel_diff(mmrm_ests), rel_diff(lmer_ests), rel_diff(gls_ests),
    rel_diff(glmmtmb_ests)
  )
) %>%
  mutate(converged = factor(converged, levels = c(TRUE, FALSE)))

# plot estimates
rel_diff_ests_tbl %>%
  ggplot(
    aes(x = parameter, y = rel_diff, color = estimator, shape = converged)
  ) +
  geom_point(position = position_dodge(width = 0.5)) +
  geom_hline(yintercept = 0, linetype = 2, alpha = 0.5) +
  scale_color_discrete(name = "Procedure") +
  scale_shape_discrete(name = "Convergence") +
  ylab("Relative Difference") +
  xlab("Marginal Treatment Effect") +
  ggtitle("Average Treatment Effect Estimates Relative to SAS Estimates") +
  theme_classic()

# excluding glmmTMB
rel_diff_ests_tbl %>%
  dplyr::filter(estimator != "glmmTMB") %>%
  ggplot(
    aes(x = parameter, y = rel_diff, color = estimator, shape = converged)
  ) +
  geom_point(position = position_dodge(width = 0.5)) +
  geom_hline(yintercept = 0, linetype = 2, alpha = 0.5) +
  scale_color_discrete(name = "Procedure") +
  scale_shape_discrete(name = "Convergence") +
  ylab("Relative Difference") +
  xlab("Marginal Treatment Effect") +
  ggtitle(
    "Average Treatment Effect Estimates Relative to SAS Estimates
      (Excluding glmmTMB)"
  ) +
  theme_classic()
```

`mmrm`, `gls` and `lmer` produce estimates that are virtually identical to `PROC
MIXED`'s, while `glmmTMB` does not. This is likely explained by `glmmTMB`'s
failure to converge. Note too that `lmer` fails to converge.


## Impact of Missing Data on Convergence Rates

The results of the previous benchmark suggest that the amount of patients
missing from later time points affect certain implementations' capacity to
converge. We investigate this further by simulating data using a data-generating
process similar to that of the BCVA datasets, though with various rates of
patient dropout.

Ten datasets of 200 patients are generated each of the following levels of
missingness: none, mild, moderate, and high. In all scenarios, observations are
missing at random. The number patients observed at each visit is obtained for
one replicated dataset at each level of missingness is presented in the table
below.

```{r dgp-functions, echo=FALSE}
# helper function for generating covariates
generate_covariates <- function(n_obs, n_visits = 10) {
  # participant ID
  participant <- seq_len(n_obs)

  # baseline best corrected visual acuity score
  base_bcva <- rnorm(n = n_obs, mean = 75, sd = 10)

  # stratification factor
  strata <- as.vector(
    c(1, 2, 3) %*% rmultinom(n = n_obs, 1, prob = c(0.3, 0.3, 0.4))
  )

  # treatment indicator
  trt <- rbinom(n = n_obs, size = 1, prob = 0.5)

  # visit number
  visit_num <- rep(seq_len(n_visits), n_obs)

  # assemble into a covariates data.frame
  data.frame(
    participant = rep(participant, each = n_visits),
    base_bcva = rep(base_bcva, each = n_visits),
    strata = as.factor(rep(strata, each = n_visits)),
    trt = rep(trt, each = n_visits),
    visit_num
  )
}

# helper function for randomly generating unstructured covariance matrix
compute_unstructured_matrix <- function(
    vars = seq(from = 1, by = 0.5, length.out = 10)) {
  n_visits <- length(vars)
  corr_mat <- abs(cov2cor(
    clusterGeneration::genPositiveDefMat(dim = n_visits)$Sigma
  ))
  sd_mat <- diag(sqrt(vars))
  us_mat <- sd_mat %*% corr_mat %*% sd_mat
  return(us_mat)
}

# helper function for generating BCVA data
generate_outcomes <- function(
    covars_df,
    cov_mat,
    intercept = 5,
    base_bcva_coef = 1,
    strata_2_coef = -1,
    strata_3_coef = 1,
    trt_coef = 1,
    visit_coef = 0.25,
    trt_visit_coef = 0.25) {
  # construct the model matrix
  model_mat <- model.matrix(
    ~ base_bcva + strata + trt * visit_num,
    data = covars_df
  )

  # generate the bvca outcomes
  n_visits <- nrow(cov_mat)
  n_obs <- nrow(covars_df) / n_visits
  effect_coefs <- c(
    intercept, base_bcva_coef, strata_2_coef, strata_3_coef,
    trt_coef, visit_coef, trt_visit_coef
  )
  as.vector(model_mat %*% effect_coefs +
    as.vector(t(MASS::mvrnorm(n_obs, rep(0, n_visits), cov_mat))))
}

# MAR helper function
missing_at_random <- function(covars_df, type) {
  # compute missingness probabilities
  if (type == "none") {
    prob_miss <- 0
  } else if (type == "mild") {
    prob_miss <- plogis(
      -(5 - 0.01 * covars_df$base_bcva + 0.5 * (covars_df$strata == 2) +
        1 * (covars_df$strata == 3) - 0.3 * covars_df$visit_num - 0.2 *
          (covars_df$trt == 0))
    )
  } else if (type == "moderate") {
    prob_miss <- plogis(
      -(5 - 0.01 * covars_df$base_bcva + 0.5 * (covars_df$strata == 2) +
        1 * (covars_df$strata == 3) - 0.4 * covars_df$visit_num - 0.5 *
          (covars_df$trt == 0))
    )
  } else if (type == "high") {
    prob_miss <- plogis(
      -(5 - 0.02 * covars_df$base_bcva + 0.5 * (covars_df$strata == 2) +
        1 * (covars_df$strata == 3) - 0.5 * covars_df$visit_num - 1 *
          (covars_df$trt == 0))
    )
  }

  # generate vector of missingness indicators
  missing_ind <- rbinom(nrow(covars_df), 1, prob_miss)

  # remove indicated visits
  covars_df[missing_ind == 0, ]
}

# BCVA data-generating process
rct_dgp_fun <- function(
    n_obs = 1000,
    outcome_covar_mat = compute_unstructured_matrix(),
    trt_coef = 0.25,
    visit_coef = 0.25,
    trt_visit_coef = 0.25,
    missing_type = "moderate") {
  # generate the covariates
  covars_df <- generate_covariates(
    n_obs = n_obs, n_visits = nrow(outcome_covar_mat)
  )

  # generate the outcomes
  bcva_out <- generate_outcomes(
    covars_df = covars_df,
    cov_mat = outcome_covar_mat,
    trt_coef = trt_coef,
    visit_coef = visit_coef,
    trt_visit_coef = trt_visit_coef
  )

  # compute the change in BCVA
  bcva_change <- bcva_out - covars_df$base_bcva

  # assemble into a data.frame
  df <- data.frame(
    participant = covars_df$participant,
    bcva_change = bcva_change,
    base_bcva = covars_df$base_bcva,
    strata = covars_df$strata,
    trt = covars_df$trt,
    visit_num = covars_df$visit_num
  )

  # delete observations at random
  df <- missing_at_random(df, type = missing_type)

  # format to resemble FEV dataset
  df <- df %>%
    transmute(
      USUBJID = factor(participant),
      VISITN = visit_num,
      AVISIT = paste0("VIS", str_pad(visit_num, width = 2, pad = "0")),
      AVISIT = factor(
        AVISIT,
        levels = paste0("VIS", str_pad(seq_len(10), width = 2, pad = "0"))
      ),
      ARMCD = ifelse(trt == 1, "TRT", "CTL"),
      RACE = ifelse(strata == 1, "Black",
        ifelse(strata == 2, "Asian", "White")
      ),
      BCVA_BL = base_bcva,
      BCVA_CHG = bcva_change
    )

  return(df)
}
```

```{r missingness-table, warning=FALSE, message=FALSE, echo=FALSE}
# extract the number of patients at each visit
bcva_none <- rct_dgp_fun(n_obs = 200, missing_type = "none") %>%
  pull(AVISIT) %>%
  table()
bcva_mild <- rct_dgp_fun(n_obs = 200, missing_type = "mild") %>%
  pull(AVISIT) %>%
  table()
bcva_moderate <- rct_dgp_fun(n_obs = 200, missing_type = "moderate") %>%
  pull(AVISIT) %>%
  table()
bcva_high <- rct_dgp_fun(n_obs = 200, missing_type = "high") %>%
  pull(AVISIT) %>%
  table()

## construct the table
bind_cols(
  tibble(Missingness = c("none", "mild", "moderate", "high")),
  bind_rows(bcva_none, bcva_mild, bcva_moderate, bcva_high)
) %>%
  kable(caption = "Number of patients per visit")
```

The convergence rates of all implementations for stratified by missingness level
is presented in the plot below.

```{r convergence-rate-missingness, warning=FALSE, message=FALSE, echo=FALSE}
get_convergence_rates <- function(n_replicates, missingness_level) {
  purrr::map_df(
    seq_len(n_replicates),
    function(idx) {
      ## simulate the data
      miss_df <- rct_dgp_fun(n_obs = 200, missing_type = missingness_level)

      ## fit MMRM methods and extract convergence

      ## mmrm
      safe_mmrm <- safely(mmrm)
      mmrm_fit <- safe_mmrm(
        formula = BCVA_CHG ~ BCVA_BL + RACE + ARMCD * AVISIT + us(AVISIT | USUBJID),
        data = miss_df
      )
      mmrm_converged <- is.null(mmrm_fit$error)
      mmrm_converged

      ## lme4
      lmer_fit <- lmer(
        BCVA_CHG ~ BCVA_BL + RACE + ARMCD * AVISIT + (0 + AVISIT | USUBJID),
        data = miss_df[complete.cases(miss_df), ],
        control = lmerControl(check.nobs.vs.nRE = "ignore")
      )
      lmer_converged <- all(!str_detect(
        lmer_fit@optinfo$conv$lme4$messages,
        "Model failed to converge"
      ))

      ## nlme
      safe_gls <- safely(gls)
      gls_fit <- safe_gls(
        BCVA_CHG ~ BCVA_BL + RACE + ARMCD * AVISIT,
        data = miss_df[complete.cases(miss_df), ],
        correlation = nlme::corSymm(form = ~ VISITN | USUBJID),
        weights = nlme::varIdent(form = ~ 1 | VISITN)
      )
      gls_converged <- is.null(gls_fit$error)

      ## glmmTMB
      glmmtmb_fit <- glmmTMB(
        BCVA_CHG ~ BCVA_BL + RACE + ARMCD * AVISIT + us(0 + AVISIT | USUBJID),
        data = miss_df,
        dispformula = ~0
      )
      glmmtmb_converged <- glmmtmb_fit$fit$convergence == 0

      ## SAS
      if (file.exists("sascfg_personal.py")) {
        # compute marginal estimates from PROC MIXED
        # load the data into SAS
        df2sd(miss_df, "miss_df")

        sas_code <- "ODS OUTPUT ConvergenceStatus = conv_status;
          PROC MIXED DATA = miss_df cl method=reml;
            CLASS AVISIT(ref = 'VIS01') RACE(ref = 'Asian') ARMCD(ref = 'CTL') USUBJID;
            MODEL BCVA_CHG = BCVA_BL ARMCD AVISIT ARMCD*AVISIT RACE / ddfm=satterthwaite solution chisq;
            REPEATED AVISIT / subject=USUBJID type=un r rcorr;
          RUN;
        "

        # generate the SAS output
        sas_result <- run_sas(sas_code)

        ## extract the convergence status
        conv_status_df <- sasr::sd2df("conv_status")
        sas_converged <- conv_status_df$Reason == "Convergence criteria met."

        ## assemble tibble row
        results <- tibble(
          replicate = idx,
          method = c("mmrm", "lmer", "gls", "glmmTMB", "PROC MIXED"),
          converged = c(
            mmrm_converged, lmer_converged, gls_converged,
            glmmtmb_converged, sas_converged
          )
        )
      } else {
        results <- tibble(
          replicate = idx,
          method = c("mmrm", "lmer", "gls", "glmmTMB"),
          converged = c(
            mmrm_converged, lmer_converged, gls_converged,
            glmmtmb_converged
          )
        )
      }

      return(results)
    }
  ) %>%
    group_by(method) %>%
    summarize(convergence_rate = mean(converged), .groups = "drop") %>%
    mutate(missingness = missingness_level)
}

## get the convergence rates
n_reps <- 10
cr_no_missing <- get_convergence_rates(n_reps, "none")
cr_mild_missing <- get_convergence_rates(n_reps, "mild")
cr_moderate_missing <- get_convergence_rates(n_reps, "moderate")
cr_high_missing <- get_convergence_rates(n_reps, "high")
cr_all <- bind_rows(
  cr_no_missing, cr_mild_missing, cr_moderate_missing, cr_high_missing
)

## plot the convergence rates
cr_all %>%
  mutate(
    missingness = factor(
      missingness,
      levels = c("none", "mild", "moderate", "high")
    )
  ) %>%
  ggplot(aes(x = method, y = convergence_rate)) +
  geom_point() +
  facet_grid(rows = vars(missingness)) +
  xlab("Method") +
  ylab("Convergence Rate (10 Replicates)") +
  ggtitle("Convergence Rates by Missingness Levels") +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  theme_bw()
```

`mmrm`, `gls`, and `PROC MIXED` are resilient to missingness, only exhibiting
some convergence problems in the scenarios with the most missingness. These
implementations converged in all the other scenarios' replicates. `glmmTMB`, on
the other hand, has convergence issues in the no-, mild-, and high-missingness
datasets, with the worst convergence rate occurring in the datasets with the
most dropout. Finally, `lmer` is unreliable in all scenarios, suggesting that
it's convergence issues stem from something other than the missing observations.

Note that the default optimization schemes are used for each method; these
schemes can be modified to potentially improve convergence rates.

A more comprehensive simulation study using data-generating processes similar to
the one used here is outlined in the
[`simulations/missing-data-benchmarks`](https://github.com/openpharma/mmrm/tree/main/simulations/missing-data-benchmarks)
subdirectory. In addition to assessing the effect of missing data on software
convergence rates, we also evaluate these methods' fit times and empirical bias,
variance, 95% coverage rates, type I error rates and type II error rates. `mmrm`
is found to be the most most robust software for fitting MMRMs in scenarios
where a large proportion of patients are missing from the last time points.
Additionally, `mmrm` has the fastest average fit times regardless of the amount
of missingness. All implementations considered produce similar empirical biases,
variances, 95% coverage rates, type I error rates and type II error rates.

# Session Information

```{r session-info, echo=FALSE}
sessionInfo()
```
