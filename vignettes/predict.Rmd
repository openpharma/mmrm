---
title: "Predicting from a MMRM"
package: mmrm
output:
  rmarkdown::html_document:
          theme: "spacelab"
          highlight: "kate"
          toc: true
          toc_float: true
vignette: |
  %\VignetteIndexEntry{Predicting from a MMRM}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(mmrm)
```

## Prediction of conditional mean

Let $Y^{(i)}$ be the $n$ outcomes of the $i$-th subject and $X^{(i)}$ the $n\times p$
matrix of covariates for subject $i$.
Let further $\epsilon^{(i)}\sim\mathcal{N}(0, \Sigma(X^{(i)},\theta))$ be the vector of
(correlated) residuals where $\theta$ are the covariance parameters.

$$
Y^{(i)} \sim X^{(i)} \cdot \beta^\top + \epsilon^{(i)}
$$

Since residuals can be correlated, potentially existing observed outcomes
of the same individual can be informative for predicting the unobserved 
valued of the same individual.

Assume that the data is sorted such that $Y^{(i)}_{j} = y^{(i)}_{j}, j = k+1, k+2, \dots, p$ are
observed and $Y^{(i)}_{j}, j = 1, 2, \dots, k$ are not.
The special case of all outcomes being unobserved (new individual) is covered
with $k=p$.

Let further 
$$
\Sigma^{(i)}(\theta) = \begin{pmatrix} \Sigma^{(i)}_{new,new}(\theta) & \Sigma^{(i)}_{new,old}(\theta)\\ \Sigma^{(i)}_{old,new}(\theta) & \Sigma^{(i)}_{old,old}(\theta)\end{pmatrix}
$$

be a block decomposition where
$\Sigma^{(i)}_{new,old}(\theta) = \big(\Sigma^{(i)}_{j,l}(\theta)\big)_{j = 1\dots k,\, l = 1\ldots k}$ and

Predictions can then be made based on the conditional distribution
$$
Y^{(i)}_{1\ldots k}\,|\,X_i,Y^{(i)}_{k+1\ldots p}=y^{(i)}_{k+1\ldots p}\sim\mathcal{N}(\mu, A)
$$

with 

$$
\mu = y^{(i)}_{1\ldots k} +  \Sigma^{(i)}_{new,old}(\theta) \, \big(\Sigma^{(i)}_{old,old}(\theta)\big)^{-1} \big(y^{(i)}_{k+1\ldots p} -  (X^{(i)} \cdot \beta^\top)_{k+1\ldots p}\big)
$$
and

$$
A = \Sigma^{(i)}_{new,new}(\theta) - \Sigma^{(i)}_{old,new}(\theta) \big(\Sigma^{(i)}_{old,old}(\theta)\big)^{-1} \Sigma^{(i)}_{new,old}(\theta)
$$

For implementing `predict()` $\mu$ is required. 

For `predict(interval = "confidence")` additionally standard errors are required.
These could be derived using the delta methods since $mu$ is a function of the
estimated model parameters $\beta,\theta$.
This would require the Jacobian of $mu(\beta,\theta)$.

For `predict(interval = "prediction")` one would use the diagonal of $A$ instead,
again the delta method could be used to make upper and lower boundaries reflect
parameter estimation uncertainty.

## Example WIP (only for new individuals)

```{r}
rho <- 0.9
planned_visits <- c(0, 1, 3, 6, 12, 18)
sigma <- c(5, 7, 10, 12, 15, 20)
n <- 100L
cor <- as.matrix(0.8^dist(planned_visits)) + diag(length(planned_visits)) # 'spatial' exponential
vcov <- diag(sigma^2) %*% cor
tbl_data <- expand.grid(
    id = factor(1:n),
    month = planned_visits
  )
tbl_data <- tbl_data[order(tbl_data$id, tbl_data$month), ]
rownames(tbl_data) <- 1:nrow(tbl_data)
tmp <- matrix(rnorm(n * length(planned_visits)), nrow = n) %*% chol(vcov) +
  matrix(rep(3*planned_visits, n), nrow = n, byrow = TRUE)
tbl_data$y <- as.vector(t(tmp)) 
```

```{r}
fit <- mmrm(y ~ month + sp_exp(month | id), data = tbl_data, weights = rep(1, nrow(tbl_data)))
fit
options(max.print = 50)
predict(fit, tbl_data)
predict(fit, tbl_data, se.fit = TRUE)
predict(fit, tbl_data, se.fit = TRUE, interval = "confidence")
predict(fit, tbl_data, interval = "confidence")
```
