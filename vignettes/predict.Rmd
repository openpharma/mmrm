---
title: "Predicting from a MMRM"
package: mmrm
output:
  rmarkdown::html_document:
          theme: "spacelab"
          highlight: "kate"
          toc: true
          toc_float: true
vignette: |
  %\VignetteIndexEntry{Predicting from a MMRM}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(mmrm)
```

## Prediction of conditional mean

Since residuals can be correlated, potentially existing observed outcomes
of the same individual can be informative for predicting the unobserved 
valued of the same individual.

Assume that the data is sorted such that $Y_{ij} = y_{ij}, j = k+1, k+2, \dots, p$ are
observed and $Y_{ij}, j = 1, 2, \dots, k$ are not.
The special case of all outcomes being unobserved (new individual) is covered
with $k=p$.

Let further 
$$
\Sigma_i(X_i, \theta) = \begin{pmatrix} \Sigma_i^{new,new}(X_i,\theta) & \Sigma_i^{new,old}(X_i,\theta)\\ \Sigma_i^{old,new}(X_i,\theta) & \Sigma_i^{old,old}(X_i,\theta)\end{pmatrix}
$$

be a block decomposition where
$\Sigma_i^{new,new}(X_i,\theta) = \Big(\big(\Sigma_i(X_i,\theta)\big)_{j,l}\Big)_{j = 1\dots k,\, l = 1\ldots k}$ and
similarly for the other blocks.

Predictions can then be made based on the conditional distribution
$$
Y_{i, 1\ldots k}\,|\,X_i,Y_{i,k+1\ldots p}=y_{i, k+1\ldots p}\sim\mathcal{N}(\mu_i, A_i)
$$

with 

$$
\mu_i(\beta,\theta) = (X_i \ \beta)_{1\ldots k} +  \Sigma_i^{new,old}(X_i,\theta) \, \Big(\big(\Sigma_i^{old,old}(X_i,\theta)\big)^{-1} \big(y_i^{k+1\ldots p} -  (X_i \ \beta)_{k+1\ldots p}\big)\Big)
$$
and

$$
A_i(\beta, \theta) = \Sigma_i^{new,new}(X_i,\theta) - \Sigma_i^{old,new}(X_i,\theta) \Big(\Sigma_i^{old,old}(X_i,\theta)\Big)^{-1} \Sigma_i^{new,old}(X_i,\theta) \ .
$$
Note that $A_i$ does not depend on $\beta$.
For implementing `predict()`, only $\widehat{\mu}_i:=\mu_i(\widehat{\beta},\widehat{\theta})$
is required.

For `predict(interval = "confidence")` additionally standard errors are required.
These could be derived using the delta methods since $\mu_i$ is a function of the
estimated model parameters $\beta$ and $\theta$.
This would require the Jacobian $\nabla\mu_i(\beta,\theta)|_{\big(\widehat{\beta},\widehat{\theta}\big)}$ 
in addition to the estimated variance covariance matrix of the parameter estimate
$\big(\widehat{\beta},\widehat{\theta}\big)$, $\widehat{S}$.
Standard errors for $\widehat{\mu}^{\,(i)}$ are then given by the square root of 
the diagonal elements of
$$
\Big(\nabla\mu_i(\beta,\theta)|_{\big(\widehat{\beta},\widehat{\theta}\big)}\Big)^\top\quad \widehat{S} \quad \Big(\nabla\mu_i(\beta,\theta)|_{\big(\widehat{\beta},\widehat{\theta}\big)}\Big)
$$
For `predict(interval = "prediction")` one would use the square root of the 
diagonal elements of $A_i\big(\widehat{\beta},\widehat{\theta}\big)$ instead.
The delta method could again be used to make upper and lower boundaries reflect
parameter estimation uncertainty (how exactly?).

Alternatively, both intervals can be derived using a parametric bootstrap sample
of the unrestricted parameters $(\beta, \theta)$.
This would probably also be easier for the `= "prediction"` case.


## Example WIP (only for new individuals)

```{r}
rho <- 0.9
planned_visits <- c(0, 1, 3, 6, 12, 18)
sigma <- c(5, 7, 10, 12, 15, 20)
n <- 100L
cor <- as.matrix(0.8^dist(planned_visits)) + diag(length(planned_visits)) # 'spatial' exponential
vcov <- diag(sigma^2) %*% cor
tbl_data <- expand.grid(
    id = factor(1:n),
    month = planned_visits
  )
tbl_data <- tbl_data[order(tbl_data$id, tbl_data$month), ]
rownames(tbl_data) <- 1:nrow(tbl_data)
tmp <- matrix(rnorm(n * length(planned_visits)), nrow = n) %*% chol(vcov) +
  matrix(rep(3*planned_visits, n), nrow = n, byrow = TRUE)
tbl_data$y <- as.vector(t(tmp)) 
```

```{r}
fit <- mmrm(y ~ month + sp_exp(month | id), data = tbl_data, weights = rep(1, nrow(tbl_data)))
fit
options(max.print = 50)
predict(fit, tbl_data)
predict(fit, tbl_data, se.fit = TRUE)
predict(fit, tbl_data, se.fit = TRUE, interval = "confidence")
predict(fit, tbl_data, interval = "confidence")
```
