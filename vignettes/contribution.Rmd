---
title: "Contributing Guide for Developers"
package: mmrm
author:
  - name: Liming Li
output:
  rmarkdown::html_document:
          theme: "spacelab"
          highlight: "kate"
          toc: true
          toc_float: true
vignette: |
  %\VignetteIndexEntry{Contributing Guide for Developers}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
---

# Introduction

As `mmrm` package is built on `TMB` with complex structure, it might be hard for new developers to onboard.
To make it easier for new developers to join, this documentation is created.

# Package Structures

`mmrm` is an R package, and the following sections describe all files/folders that are contained in this package.

## data

The `data/` folder is where `mmrm` internal data is stored.
Currently, we only have `fev_data.rda` in this folder.
In turn, `fev_data.rda` only contains the `fev_data` dataset.

`fev_data` is a data frame of the following structure:

```{r}
head(fev_data)
```

`USUBJID` is the unique subject id(total 200 subjects), `AVISIT` is the analysis visit(from VIS1 to VIS4), `TRT` is the treatment assignment,
`RACE` is the race of subject, `SEX` is the gender of subject, `FEV1` is the forced expiratory volume, `FEV1_BL` is the baseline forces expiratory volume.
`WEIGHT` is the weight for each observation, `VISITN` is the numeric value of `AVISIT` (taking the prefix "VIS" off from AVISIT), `VISITN2` is a numeric value.

In `mmrm` analysis, we usually use `FEV1` as the response, `AVISIT` as the time variable, and `USUBJID` as subject variable.
See [introduction](introduction.html#common-usage).

## design

The `design/` folder is where the prototypes and SAS implementations stored.
When we have a new idea for a specific implementations, we can add our prototypes in a Rmarkdown file to this folder.
We can then push these prototypes to github and collect feedback on the proposed ideas.
Currently we only have SAS and TMB folders.

### SAS

The `design/SAS/` folder contains the programs to run MMRM models and corresponding SAS outputs.
The results will be used for integration tests.
See [integration tests](#how-to-add-a-new-integration-test?).

### TMB

The `design/TMB/` folder is where prototypes of `mmrm` implementations stored.
You can add your ideas/prototypes here.

## inst

Files in the `inst/` folder will be kept after installation.
Currently we only have `REFERENCES.bib` and `WORDLIST` under this folder.
`REFERENCES.bib` keeps a list of all referenced literature.
`WORDLIST` is kept up-to-date for all non-English words, allowing the package to pass a spell-checker.

## man

The `man/` folder contains all function documentation generated by `Roxygen`.
Please do not edit any file in this folder otherwise you may run into issues.

## R

This folder contains all the source code written in R, just like every other R packages.

### catch-routine-registration.R

This file is generated automatically to ensure C++ tests can be conducted with `testthat` and `Catch`.
For more details, visit [use catch in testthat](https://testthat.r-lib.org/reference/use_catch.html) page.

### component.R

This file contains the function `component`, which extracts corresponding information from `mmrm_tmb` object.
For more details, visit [other component](introduction.html#other-component) page.

### data.R

This file contains the documentation of all the data we have in `mmrm` package.
Currently, we only have `fev_data`.
For more details, visit [data](#data) page.

### emmeans.R

This file includes the interface between package `emmeans` and `mmrm`, with which we can derive the estimated
marginal means using `emmeans` package.
For more details, visit [support for emmeans](introduction.html#support-for-emmeans) page.

### fit.R

This file includes high-level functions for fitting `mmrm` models, including [`mmrm()`](../reference/mmrm.html),
[`fit_single_optimizer()`](../reference/fit_single_optimizer.html) and [`refit_multiple_optimizers()`](../reference/refit_multiple_optimizers.html).
The general usage are documented in [common usage](introduction.html#common-usage) page.

### mmrm-methods.R

This file includes S3 methods for summarizing of mmrm object, printing the summary, and other supporting functions, see [`mmrm_methods`](../reference/mmrm_methods.html).

### mmrm-package.R

This file is the package documentation.

### satterthwaite.R

This file includes hypothesis testing of one-dimensional and multi-dimensional contrasts with [`df_1d()`](../reference/df_1d.html)
and [`df_md()`](../reference/df_md.html) and supporting functions.

### tmb-methods.R

This file includes S3 methods for `mmrm_tmb` objects, see [mmrm_tmb_methods](../reference/mmrm_tmb_methods.html).

### tmb.R

This file includes low-level functions for fitting `mmrm` models, including [`h_mmrm_tmb()`](../reference/h_mmrm_tmb.html),
and [`h_mmrm_tmb_control()`](../reference/h_mmrm_tmb_control.html), and other supporting functions.

The documentation for usage of low-level functions can be found at [low-level mmrm](introduction.html#low-level-mmrm).

### utils.R

This file includes some utility function/objects.

## src

src folders includes all the source code written in C++.
Files starting with `test-` are tests.

### covariance.h

This file includes the implementations of covariance structures with suitable parameterization,
and the calculation of lower triangular part of Cholesky factorization of the covariance matrix.

For more about the implementations and why Cholesky factorization is needed, visit [mmrm details vignette](algorithm.html#covariance-matrix-model).

For more about covariance structures, visit [covariance structures vignette](covariance.html).

### init.h

This file includes the initialization of R and C++ communication.

### mmrm.cpp

This file is the core part where the likelihood is calculated.
The objective function reads input from R and do the calculations inside.

### utils.h

This files includes utilities that used internally.

### tmb.cpp and tmb_includes.h

These two files includes the TMB module.

### test- files

All files starting with `test-` are unit tests for the C++ codes.

## tests

The `tests/` folder includes all the unit tests for the R functions, using the `testthat` package.

## vignettes

The `vignettes/` folder includes `Rmarkdown`-based documentation to helps the user understand more about the usage, detail, etc. These vignettes are rendered into `.html` files which are deployed on the package website. 

## other files

There are other files that can be helpful in package development.

### .gitignore

This file will specify untracked files/file patterns that git should ignore.

### .lintr

This file serves as configuration for `lintr` to do the static code analysis.
Please install `lintr` package in your developing system to enable the analysis.
It will provide you information about errors, style issues, etc.

For more, visit [lintr documentation](https://lintr.r-lib.org/).

### .pre-commit-config.yaml

This file includes the configurations that we use for `pre-commit`.
`pre-commit` is a tool that help us identify simple issues before we submit our code.
For more, visit [pre-commit documentation](https://pre-commit.com/).


### _pkgdown.yml

This file is the configuration file for our `pkgdown`-based website.
`pkgdown` is used to covert our package documentation (`man/`, `vignettes/`) into our package website.

For more, visit [pkgdown documentation](https://pkgdown.r-lib.org/).

### staged_dependencies.yaml

This file is the configuration file for `staged.dependencies`.
`staged.dependencies` is used to ensure that dependencies are consistent across multiple repositories which are being developing at the same time.

For more, visit [staged.dependencies documentation](https://openpharma.github.io/staged.dependencies/).

# Package conventions

Before contributing to this package, there are some conventions to follow.

## Programming conventions

1. Function names should be explicit and clear, separated by underscore (`snake_case`).
2. Functions starting with `h_` are supporting functions and they should not be exported.
3. Functions should be well documented using `roxygen2` even when they are not exported.

## Github conventions

When using github to collaborate, the following conversions are needed:

1. Github issues is for issues, feature requests, bugs. Before creating a issue, please make sure this issue has not been reported yet.
    * If you are going to work on this issue, please assign yourself.
2. Please create a branch in the `mmrm` repository, instead of creating forks, unless you are not yet a team member.
    * The name of a branch should be like `<issue_id>_<short_discription>`. Use an underscore to separate the description.
3. Please create a Pull Request when you think your code changes are ready:
    * they are well documented
    * they have corresponding unit tests.
    * they pass all the github action checks
4. Address all the comments you receive.
    * at least one approval is needed to merge.

# How to contribute?

## How to set up development environment?

The development this `mmrm` package is based on the latest R and C++ compilers.
The package dependencies are the most recent versions from CRAN.
We recommend that your working environment is set up in the same way.
Additionally, there are some tools we recommend you to install:

1. `docker`. This tool will create a distinct environment which allows you to separate the host system and development system.
2. `gitkraken`. This tool is a super useful in visualizing git commit graphs, file history, etc.
3. `lintr`. This R package will allow you to perform static code analysis. See [.lintr](#.lintr)
4. `pre-commit`. This is a python module that allow you to identify issues before you commit. See [.pre-commit-config.yaml](#.pre-commit-config.yaml)

## How to pick issues?

The issues are categorized with several labels:

1. `SP[1-9]`. `SP` (story points) indicate complexity, and the larger the subsequent number, the more time consuming the issue is expected to be.
2. `priority`. Issues with this label should be completed with higher priority.
3. `good first issue`. Issues with this label are good choices for new team members.

Other labels are straightforward.
Please choose an issue based on your interest, issue complexity, and priority.

## How to add a new test case?

To add a new test case, you need to first identify the test scope.
Does the test fit in the scope of existing tests?
If so, please modify the existing test files under `tests/testthat/` folder or `src/` folder, depending on whether the code to be tested is R or C++.
Otherwise please create a new test file, with a name prefix of "test-".

In each test case, use the following structure:

```{r eval=FALSE}
test_that("<function_name> do something as explained", {
  # test body
  expect_identical(1, 1)
})
```

The purpose of the test should be clearly stated first.

In the test body part, conduct the tests, e.g. use `expect_identical` to check consistency, `expect_error` to catch error messages, etc.
The test body should not follow the same implementation logic as the package did, otherwise we may miss mistakes in implementation.

## How to add a new integration test?

Integration tests compare the results of SAS and R and assures the quality of our code.
To add an integration test, you need to do the following:

1. Use SAS to run an appropriate mmrm models with `proc mixed`, using `fev_data`.
2. Save the results in `txt` format in the `design/SAS/` folder.
3. Decide the key outputs that is needed for comparison.
4. Add a unit test that the R implementation of the same model has the same results(conversion can be needed).

## How to get started with C++?

If you have no experience with C++, it is totally fine: `TMB` has provided us with many high-level functionalities that is very similar to `R`.
Here we only list the most important things that you need to go through before you begin C++ programming.

1. Semicolons. C++ use semicolons to terminate a statement. In R, we can use semicolons or line breaks to do so, but in C++, we need both semicolons and line breaks.
2. Types. C++ is a strong type programming language and all objects need to be declared with type. Sometimes you can combine the declaration and definition.
    1. int i = 1; # this works; declare `i` as `int` and define it to be 1.
    2. i = 1; # this fails; `i` is not declared yet.
    3. int i; i = 1; # this works; `i` is declared and then defined.
    4. int i = 1, j = 2; # this works, `i` and `j` are both `int`.
3. Object scope. In R, objects declared inside control flows will exist outside of that enclosing brackets of the flow, while in C++, objects created within control flows will be terminated.
    1. in R, `if (TRUE) { a = '123' }; print(a)` is legal.
    2. in C++, `if (1) {string a = '123'};  std::stdout << a << std::endl;` is illegal, because object `a` is terminated already.
    3. in C++, `string a; if (1) {a = '123'}; std::stdout << a << std::endl;` is legal, `a` is declared prior to if statement.
4. Polymorphism. Unlike in R, where function arguments have no explicitly defined types, in C++ the type of each argument of a function must be pre-specified.
    1. `Template` is a special function that works with generic argument type. We could imagine a single function that could work on arguments of arbitrary type, and `template` functions make this possible through separation of function logic from the argument declaration.  In this way 
    we can use template so that we don't need to replicate the whole code for each type.


With these points in mind, you are about ready to go

## How to get started with TMB?

In `mmrm` we are not including any latent variables so the Laplace approximation part is not used.
We only use the automatic differentiation part of `TMB`.
For detailed documentation of `TMB`, visit [TMB referece](https://kaskr.github.io/adcomp/Introduction.html).
One important thing is that `TMB` implements R style matrix/array calculations.
This is important because we mainly use this part to conduct our calculations.
See [matrix_arrays.cpp](https://kaskr.github.io/adcomp/matrix_arrays_8cpp-example.html) for examples.


## How to add a new covariance structure?

To add a new covariance structure, you need to do the following

1. Understand the covariance structure and add appropriate documentation in [covariance structure](covariance.html) and you can create a draft pull request to invite discussion from other team members.
2. Implement the covariance structure on the C++ side and the corresponding R interface.
3. Add unit tests to make sure the new covariance structure is working as expected.
4. Add integration tests under `design/SAS/` folder to make sure SAS and R produce similar results (within tolerance).

## How to add additional data?

To add additional data to `mmrm`, please follow the next steps:

1. Make sure the data is needed.
2. Document the data in [R/data.R](#data.R).
3. use `save` to create an `rda` data **only** containing this dataset.

# Communications within team?

There are several communication channels, please use appropriate ones.

## github

Github issues/pull requests is where implementations are discussed and reviewed.
Feature requests, bugs, enhancements, technical implementations can be discussed here.
When you have ideas that needs to be documented, it is better to have them in github.

## slack

Slack is a messaging tools and we have a `mmrm` channel under `rinpharma` space.
You can put anything in the slack channel, e.g., you have completed a issue and are waiting for review,
or you have some questions and don't want to wait until the next stand-up meeting.

To join the slack channel, please make sure you have a slack account, and send the email address to any team member.

## stand-up meetings

We have stand-up meetings three times a week.
The purpose of stand-up meetings is for team members to discuss the current work progress and raise any issue/questions for team discussion if needed.

You don't need to join all three meetings.
